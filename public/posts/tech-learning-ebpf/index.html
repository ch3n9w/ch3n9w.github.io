<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Learning eBPF | ch3n9w の 超元域</title>
<meta name="keywords" content="">
<meta name="description" content="eBPF 是一项革命性的技术, 起源于Linux 内核, 它可以在特权上下文中(如操作系统内核)运行沙盒程序. 它用于安全有效地扩展内核的功能, 而无需通过更改内核源代码或加载内核模块的方式来实现. 从历史上看,由于内核具有监督和控制整个系统的特权,操作系统一直是实现可观测性, 安全性和网络功能的理想场所.
对ebpf慕名许久, 正好趁寒假拜读一下Learning eBPF, 虽然是基于略过时的框架bcc, 但是在这个过程中学到的知识想必依旧可以迁移到别的框架去.
Background and pre-knowledge bcc bcc的ebpf c代码不是真正的C, 而是bcc自己定义的一种和C类似的语言.
limitation of ebpf program eBPF 程序必须被验证器校验通过后才能执行，且不能包含无法到达的指令； eBPF 程序不能随意调用内核函数，只能调用在 API 中定义的辅助函数； eBPF 程序栈空间最多只有 512 字节，想要更大的存储，就必须要借助映射存储； 在内核 5.2 之前，eBPF 字节码最多只支持 4096 条指令，而 5.2 内核把这个限制提高到了 100 万条； 由于内核的快速变化，在不同版本内核中运行时，需要访问内核数据结构的 eBPF 程序很可能需要调整源码，并重新编译。 tracepoint and kprobe tracepoint其实就是在Linux内核的一些关键函数中埋下的hook点,这样在tracing的时候,我们就可以在这些固定的点上挂载调试的函数,然后查看内核的信息.
Tracepoint是在内核中固定的hook点, 并不是在所有的函数中都有tracepoint. 这时候, 我们就需要用到kprobe了. kprobe可以动态地在所有的内核函数(除了inline函数)上挂载probe函数
eBPF virtual machine The ebpf virtual machine uses 10 general-purpose registers (0-9), and additional register 10 which was used as a stack frame pointer (can only be read but not written).">
<meta name="author" content="ch3n9w">
<link rel="canonical" href="http://ch3n9w.cpolar.cn/posts/tech-learning-ebpf/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://ch3n9w.cpolar.cn/flash.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://ch3n9w.cpolar.cn/flash.ico">
<link rel="icon" type="image/png" sizes="32x32" href="http://ch3n9w.cpolar.cn/flash.ico">
<link rel="apple-touch-icon" href="http://ch3n9w.cpolar.cn/flash.ico">
<link rel="mask-icon" href="http://ch3n9w.cpolar.cn/flash.ico">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://ch3n9w.cpolar.cn/posts/tech-learning-ebpf/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Learning eBPF" />
<meta property="og:description" content="eBPF 是一项革命性的技术, 起源于Linux 内核, 它可以在特权上下文中(如操作系统内核)运行沙盒程序. 它用于安全有效地扩展内核的功能, 而无需通过更改内核源代码或加载内核模块的方式来实现. 从历史上看,由于内核具有监督和控制整个系统的特权,操作系统一直是实现可观测性, 安全性和网络功能的理想场所.
对ebpf慕名许久, 正好趁寒假拜读一下Learning eBPF, 虽然是基于略过时的框架bcc, 但是在这个过程中学到的知识想必依旧可以迁移到别的框架去.
Background and pre-knowledge bcc bcc的ebpf c代码不是真正的C, 而是bcc自己定义的一种和C类似的语言.
limitation of ebpf program eBPF 程序必须被验证器校验通过后才能执行，且不能包含无法到达的指令； eBPF 程序不能随意调用内核函数，只能调用在 API 中定义的辅助函数； eBPF 程序栈空间最多只有 512 字节，想要更大的存储，就必须要借助映射存储； 在内核 5.2 之前，eBPF 字节码最多只支持 4096 条指令，而 5.2 内核把这个限制提高到了 100 万条； 由于内核的快速变化，在不同版本内核中运行时，需要访问内核数据结构的 eBPF 程序很可能需要调整源码，并重新编译。 tracepoint and kprobe tracepoint其实就是在Linux内核的一些关键函数中埋下的hook点,这样在tracing的时候,我们就可以在这些固定的点上挂载调试的函数,然后查看内核的信息.
Tracepoint是在内核中固定的hook点, 并不是在所有的函数中都有tracepoint. 这时候, 我们就需要用到kprobe了. kprobe可以动态地在所有的内核函数(除了inline函数)上挂载probe函数
eBPF virtual machine The ebpf virtual machine uses 10 general-purpose registers (0-9), and additional register 10 which was used as a stack frame pointer (can only be read but not written)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://ch3n9w.cpolar.cn/posts/tech-learning-ebpf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-04T00:06:15+00:00" />
<meta property="article:modified_time" content="2024-02-04T00:06:15+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Learning eBPF"/>
<meta name="twitter:description" content="eBPF 是一项革命性的技术, 起源于Linux 内核, 它可以在特权上下文中(如操作系统内核)运行沙盒程序. 它用于安全有效地扩展内核的功能, 而无需通过更改内核源代码或加载内核模块的方式来实现. 从历史上看,由于内核具有监督和控制整个系统的特权,操作系统一直是实现可观测性, 安全性和网络功能的理想场所.
对ebpf慕名许久, 正好趁寒假拜读一下Learning eBPF, 虽然是基于略过时的框架bcc, 但是在这个过程中学到的知识想必依旧可以迁移到别的框架去.
Background and pre-knowledge bcc bcc的ebpf c代码不是真正的C, 而是bcc自己定义的一种和C类似的语言.
limitation of ebpf program eBPF 程序必须被验证器校验通过后才能执行，且不能包含无法到达的指令； eBPF 程序不能随意调用内核函数，只能调用在 API 中定义的辅助函数； eBPF 程序栈空间最多只有 512 字节，想要更大的存储，就必须要借助映射存储； 在内核 5.2 之前，eBPF 字节码最多只支持 4096 条指令，而 5.2 内核把这个限制提高到了 100 万条； 由于内核的快速变化，在不同版本内核中运行时，需要访问内核数据结构的 eBPF 程序很可能需要调整源码，并重新编译。 tracepoint and kprobe tracepoint其实就是在Linux内核的一些关键函数中埋下的hook点,这样在tracing的时候,我们就可以在这些固定的点上挂载调试的函数,然后查看内核的信息.
Tracepoint是在内核中固定的hook点, 并不是在所有的函数中都有tracepoint. 这时候, 我们就需要用到kprobe了. kprobe可以动态地在所有的内核函数(除了inline函数)上挂载probe函数
eBPF virtual machine The ebpf virtual machine uses 10 general-purpose registers (0-9), and additional register 10 which was used as a stack frame pointer (can only be read but not written)."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://ch3n9w.cpolar.cn/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Learning eBPF",
      "item": "http://ch3n9w.cpolar.cn/posts/tech-learning-ebpf/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Learning eBPF",
  "name": "Learning eBPF",
  "description": "eBPF 是一项革命性的技术, 起源于Linux 内核, 它可以在特权上下文中(如操作系统内核)运行沙盒程序. 它用于安全有效地扩展内核的功能, 而无需通过更改内核源代码或加载内核模块的方式来实现. 从历史上看,由于内核具有监督和控制整个系统的特权,操作系统一直是实现可观测性, 安全性和网络功能的理想场所.\n对ebpf慕名许久, 正好趁寒假拜读一下Learning eBPF, 虽然是基于略过时的框架bcc, 但是在这个过程中学到的知识想必依旧可以迁移到别的框架去.\nBackground and pre-knowledge bcc bcc的ebpf c代码不是真正的C, 而是bcc自己定义的一种和C类似的语言.\nlimitation of ebpf program eBPF 程序必须被验证器校验通过后才能执行，且不能包含无法到达的指令； eBPF 程序不能随意调用内核函数，只能调用在 API 中定义的辅助函数； eBPF 程序栈空间最多只有 512 字节，想要更大的存储，就必须要借助映射存储； 在内核 5.2 之前，eBPF 字节码最多只支持 4096 条指令，而 5.2 内核把这个限制提高到了 100 万条； 由于内核的快速变化，在不同版本内核中运行时，需要访问内核数据结构的 eBPF 程序很可能需要调整源码，并重新编译。 tracepoint and kprobe tracepoint其实就是在Linux内核的一些关键函数中埋下的hook点,这样在tracing的时候,我们就可以在这些固定的点上挂载调试的函数,然后查看内核的信息.\nTracepoint是在内核中固定的hook点, 并不是在所有的函数中都有tracepoint. 这时候, 我们就需要用到kprobe了. kprobe可以动态地在所有的内核函数(除了inline函数)上挂载probe函数\neBPF virtual machine The ebpf virtual machine uses 10 general-purpose registers (0-9), and additional register 10 which was used as a stack frame pointer (can only be read but not written).",
  "keywords": [
    
  ],
  "articleBody": "eBPF 是一项革命性的技术, 起源于Linux 内核, 它可以在特权上下文中(如操作系统内核)运行沙盒程序. 它用于安全有效地扩展内核的功能, 而无需通过更改内核源代码或加载内核模块的方式来实现. 从历史上看,由于内核具有监督和控制整个系统的特权,操作系统一直是实现可观测性, 安全性和网络功能的理想场所.\n对ebpf慕名许久, 正好趁寒假拜读一下Learning eBPF, 虽然是基于略过时的框架bcc, 但是在这个过程中学到的知识想必依旧可以迁移到别的框架去.\nBackground and pre-knowledge bcc bcc的ebpf c代码不是真正的C, 而是bcc自己定义的一种和C类似的语言.\nlimitation of ebpf program eBPF 程序必须被验证器校验通过后才能执行，且不能包含无法到达的指令； eBPF 程序不能随意调用内核函数，只能调用在 API 中定义的辅助函数； eBPF 程序栈空间最多只有 512 字节，想要更大的存储，就必须要借助映射存储； 在内核 5.2 之前，eBPF 字节码最多只支持 4096 条指令，而 5.2 内核把这个限制提高到了 100 万条； 由于内核的快速变化，在不同版本内核中运行时，需要访问内核数据结构的 eBPF 程序很可能需要调整源码，并重新编译。 tracepoint and kprobe tracepoint其实就是在Linux内核的一些关键函数中埋下的hook点,这样在tracing的时候,我们就可以在这些固定的点上挂载调试的函数,然后查看内核的信息.\nTracepoint是在内核中固定的hook点, 并不是在所有的函数中都有tracepoint. 这时候, 我们就需要用到kprobe了. kprobe可以动态地在所有的内核函数(除了inline函数)上挂载probe函数\neBPF virtual machine The ebpf virtual machine uses 10 general-purpose registers (0-9), and additional register 10 which was used as a stack frame pointer (can only be read but not written). As a BPF program is executed, values get stored in these registers to keep track of state.\neBPF uses a JIT compiler to convert eBPF bytecode to machine code that runs natively on the target CPU .\nBPF Program and Map references Loading a BPF program into kernel returns a file descriptor, which is a reference to the program and is owned by userspace process. When that process exits, the file descriptor gets released. When there are no references left to BPF program, the kernel removes the program.\nbpftool will pin the program to the filesystem, which creates additional descriptor and the program won’t exit even if bpftool exits.\nlibbpf \u0026 vmlinux vmlinux.h is drived from the kernel source headers, which includes any kernel data structures or type, and is necessary for eBPF program so that you dont have to write definitions for types like u32, u64 by hand.\nto use any BPF helper functions, it’s needed to include header files from libbpf, which includes the definitions of helper functions and is also needed in both user space and eBPF C code.\nBasic Helloworld Hash Table Map Hash Table Map is an highly useful data struction which could be accessed by ebpf program or userspace program.\n#!/usr/bin/python from bcc import BPF from time import sleep program_hello_map = r\"\"\" // define a hash table to store counter data. BPF_HASH(counter_table); int hello(void *ctx) { u64 uid; u64 counter = 0; u64 *p; // a ebpf helper function to obtain uid of current process uid = bpf_get_current_uid_gid() \u0026 0xFFFFFFFF; // update hashtable p = counter_table.lookup(\u0026uid); if (p != 0) { counter = *p; } counter ++; counter_table.update(\u0026uid, \u0026counter); return 0; } \"\"\" b = BPF(text=program_hello_map) # execve is only an interface in linux kernel, # the specific function names vary across different architectures, # thus we should find the function name before attaching it. syscall = b.get_syscall_fnname(\"execve\") # attach to execve syscall b.attach_kprobe(event=syscall, fn_name=b\"hello\") while True: sleep(2) s = \"\" # read from hash table for k,v in b[\"counter_table\"].items(): s += f\"ID: {k.value} - {v.value}\\t\" print(s) ring buffer maps Ring buffer consists of a buffer, a pointer for written, and pointer for read. The access of data depend on the movement of these two pointers. When a element was read out, the others didn’t need to change its location. Data writing may overwrite data that has not been read in a timely manner, which is permissible in some scenarios.\nThe hello world example using ring buffer in book:\nfrom bcc import BPF bpf_code = r\"\"\" BPF_RINGBUF_OUTPUT(output,1); struct data_t { int pid; int uid; char command[16]; char message[12]; }; int hello(void *ctx) { struct data_t data = {}; char message[] = \"Hello, perf_event!\"; data.pid = bpf_get_current_pid_tgid() \u003e\u003e 32; data.uid = bpf_get_current_uid_gid() \u0026 0xFFFFFFFF; bpf_get_current_comm(\u0026data.command, sizeof(data.command)); bpf_probe_read_kernel(\u0026data.message, sizeof(data.message), message); // write data into ring buffer output.ringbuf_output(\u0026data, sizeof(data), 0); return 0; } \"\"\" b = BPF(text=bpf_code) syscall = b.get_syscall_fnname(\"execve\") b.attach_kprobe(event=syscall, fn_name=b\"hello\") def print_event(cpu, data, size): # generate the data structure from C declaration automatically # This conversion allows the Python program to access the fields (pid, uid, command, message) of the data_t structure as attributes of the data object in Python. data = b[\"output\"].event(data) print(f\"{data.pid} {data.uid} {data.command.decode()} {data.message.decode()}\") # callback function after reading data b[\"output\"].open_ring_buffer(print_event) while True: # read from ring buffer, every execution will trigger callback function print_event b.ring_buffer_poll() Ring buffers are preferred over perf buffers for performance reasons, here is the difference in example code\ntail calls bpf_tail_call 是一个 eBPF 提供的机制, 它允许一个 eBPF 程序调用另一个 eBPF 程序, 类似于函数调用. 然而, 与传统的函数调用不同, bpf_tail_call 实际上是将当前程序替换为另一个程序, 而不是创建一个新的函数调用栈帧. 这意味着被调用的程序(尾调用程序)会接管当前程序的执行上下文, 并且当尾调用程序开始执行时, 原始程序的执行就结束了.\nbpf的栈帧空间只有512字节. tail call的通用目的是为了避免当函数递归调用时,栈帧无限地增加(这会导致栈溢出)\nfrom bcc import BPF import ctypes as ct bpf_code = \"\"\" // define maps of type BPF_MAP_TYPE_PROG_ARRAY BPF_PROG_ARRAY(syscall, 300); int hello(struct bpf_raw_tracepoint_args *ctx) { // get opcode of syscall int opcode = ctx-\u003eargs[1]; // different tail call according to opcode // This line will be replaced with bpf_tail_call() helper function by bcc bofore compiling. syscall.call(ctx, opcode); // If there is no matched program, then continue execution. bpf_trace_printk(\"Another syscall: %d\", opcode); return 0; } int hello_exec(void *ctx) { bpf_trace_printk(\"execve syscall\"); return 0; } int hello_timer(struct bpf_raw_tracepoint_args *ctx) { if (ctx-\u003eargs[1] == 222) { bpf_trace_printk(\"Create a timer\"); } else if (ctx-\u003eargs[1] == 226) { bpf_trace_printk(\"Delete a timer\"); } else { bpf_trace_printk(\"Aome other timer opration\"); } return 0; } int ignore_opcode(void *ctx) { return 0; } \"\"\" b = BPF(text=bpf_code) # This time, we attach ebpf program to tracepoint named sys_enter rather than a kprobe b.attach_raw_tracepoint(tp=b\"sys_enter\", fn_name=b\"hello\") # Get file descriptors of functions ignore_fn = b.load_func(\"ignore_opcode\", BPF.RAW_TRACEPOINT) exec_fn = b.load_func(\"hello_exec\", BPF.RAW_TRACEPOINT) timer_fn = b.load_func(\"hello_timer\", BPF.RAW_TRACEPOINT) prog_array = b.get_table(\"syscall\") # put descriptors into map of syscalls prog_array[ct.c_int(59)] = ct.c_int(exec_fn.fd) prog_array[ct.c_int(222)] = ct.c_int(timer_fn.fd) prog_array[ct.c_int(223)] = ct.c_int(timer_fn.fd) prog_array[ct.c_int(224)] = ct.c_int(timer_fn.fd) prog_array[ct.c_int(225)] = ct.c_int(timer_fn.fd) prog_array[ct.c_int(226)] = ct.c_int(timer_fn.fd) # Ignore some syscalls that come up a lot prog_array[ct.c_int(21)] = ct.c_int(ignore_fn.fd) # ...... prog_array[ct.c_int(291)] = ct.c_int(ignore_fn.fd) b.trace_print() Simple XDP program in C Bcc provide a convenient way to write and run ebpf program, however, it would be better to dive deeply in order to have better understand. So, here is a XDP program written in C.\n#include #include int counter = 0; // define that this is an eXpress Data Path (XDP) program SEC(\"xdp\") int hello(void *ctx) { counter++; // same as bpf_trace_printk() in bcc, both of them are wrappers around kernel function `bpf_trace_printk` bpf_printk(\"Helloworld %d\", counter); return XDP_PASS; } // define license for this program char _license[] SEC(\"license\") = \"GPL\"; This program do nothing but print variable count everytime the XDP event been triggered, which means a network packet arrives inbound on a network interface.\nAfter writting, we need to compile and load it.\n# compile, here we got the bytecode of the program clang -O2 -target bpf -c hello.bpf.c -o hello.bpf.o # load program into kernel, here the bytecode will be transformed to machine code. bpftool prog load hello.bpf.o /sys/fs/bpf/hello # inspect the loaded program bpftool prog list bpftool prog show id 95 --pretty bpftool prog show name hello # attach to XDP event on a network interface bpftool net attach xdp id 95 dev enp0s31f6 # check the program bpftool net list # check the output cat /sys/kernel/debug/tracing/trace_pipe # check the global variable counter bpftool map dump name hello.bss # detach the program bpftool net detach xdp dev enp0s31f6 bpftool usage # load program into kernel bpftool prog load hello.bpf.o /sys/fs/bpf/hello # inspect the loaded program bpftool prog list bpftool prog show id 95 --pretty bpftool prog show name hello # attach to XDP event on a network interface bpftool net attach xdp id 95 dev enp0s31f6 # check the program bpftool net list # check the global variable counter bpftool map dump name hello.bss # detach the program bpftool net detach xdp dev enp0s31f6 # list btf (bpf type format) bpftool btf list # inspect the contents of BTF information bpftool btf dump id 251 # generate header file from BTF information bpftool btf dump file /sys/kernel/btf/vmlinux format c \u003e vmlinux.h CO-RE (Compile Once, Run Everywhere) eBPF Programs #include \"vmlinux.h\" #include #include #include char message[12] = \"Hello World\"; struct { __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY); __uint(key_size, sizeof(u32)); __uint(value_size, sizeof(u32)); } output SEC(\".maps\"); struct data_t { int pid; int uid; char command[16]; char message[12]; char path[16]; }; struct user_msg_t { char message[12]; }; // This structure is used to define the map, not map itself // however, my_config can be the map's reference struct { __uint(type, BPF_MAP_TYPE_HASH); __uint(max_entries, 10240); __type(key, u32); __type(value, struct user_msg_t); } my_config SEC(\".maps\"); // Tells the loader to attach to the program to the kprobe in the execve syscall // BPF_KPROBE_SYSCALL is a macro that expands to the correct BPF program type // The first argument is the name of the program: hello // The second argument is the executable pathname for execve syscall SEC(\"ksyscall/execve\") int BPF_KPROBE_SYSCALL(hello, const char *pathname) { struct data_t data = {}; struct user_msg_t *p; data.pid = bpf_get_current_pid_tgid() \u003e\u003e 32; data.uid = bpf_get_current_uid_gid() \u0026 0xFFFFFFFF; bpf_get_current_comm(\u0026data.command, sizeof(data.command)); bpf_probe_read_user_str(\u0026data.path, sizeof(data.path), pathname); // my_config is the map's reference p = bpf_map_lookup_elem(\u0026my_config, \u0026data.uid); if (p != 0) { bpf_probe_read_kernel_str(\u0026data.message, sizeof(data.message), p-\u003emessage); } else { bpf_probe_read_kernel_str(\u0026data.message, sizeof(data.message), message); } // submit the data to the user space bpf_perf_event_output(ctx, \u0026output, BPF_F_CURRENT_CPU, \u0026data, sizeof(data)); return 0; } char LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\"; The Makefile\nTARGET = hello-buffer-config ARCH = $(shell uname -m | sed 's/x86_64/x86/' | sed 's/aarch64/arm64/') BPF_OBJ = ${TARGET:=.bpf.o} USER_C = ${TARGET:=.c} USER_SKEL = ${TARGET:=.skel.h} all: $(TARGET) $(BPF_OBJ) find-map .PHONY: all $(TARGET): $(USER_C) $(USER_SKEL) gcc -Wall -o $(TARGET) $(USER_C) -L../libbpf/src -l:libbpf.a -lelf -lz %.bpf.o: %.bpf.c vmlinux.h clang \\ -target bpf \\ -D __TARGET_ARCH_$(ARCH) \\ -Wall \\ -O2 -g -o $@ -c $\u003c $(USER_SKEL): $(BPF_OBJ) bpftool gen skeleton $\u003c \u003e $@ vmlinux.h: bpftool btf dump file /sys/kernel/btf/vmlinux format c \u003e vmlinux.h clean: - rm $(BPF_OBJ) - rm $(TARGET) - rm find-map find-map: find-map.c gcc -Wall -o find-map find-map.c -L../libbpf/src -l:libbpf.a -lelf -lz load:\nbpftool prog load hello.bpf.o /sys/fs/bpf/hello ",
  "wordCount" : "1560",
  "inLanguage": "en",
  "datePublished": "2024-02-04T00:06:15Z",
  "dateModified": "2024-02-04T00:06:15Z",
  "author":{
    "@type": "Person",
    "name": "ch3n9w"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://ch3n9w.cpolar.cn/posts/tech-learning-ebpf/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "ch3n9w の 超元域",
    "logo": {
      "@type": "ImageObject",
      "url": "http://ch3n9w.cpolar.cn/flash.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://ch3n9w.cpolar.cn/" accesskey="h" title="ch3n9w の 超元域 (Alt + H)">
                <img src="http://ch3n9w.cpolar.cn/sabito.jpg" alt="" aria-label="logo"
                    height="35">ch3n9w の 超元域</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://ch3n9w.cpolar.cn/categories/" title="categories">
                    <span>categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://ch3n9w.cpolar.cn/">Home</a>&nbsp;»&nbsp;<a href="http://ch3n9w.cpolar.cn/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Learning eBPF
    </h1>
    <div class="post-meta"><span title='2024-02-04 00:06:15 +0000 UTC'>February 4, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1560 words&nbsp;·&nbsp;ch3n9w

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#background-and-pre-knowledge">Background and pre-knowledge</a>
      <ul>
        <li><a href="#bcc">bcc</a></li>
        <li><a href="#limitation-of-ebpf-program">limitation of ebpf program</a></li>
        <li><a href="#tracepoint-and-kprobe">tracepoint and kprobe</a></li>
        <li><a href="#ebpf-virtual-machine">eBPF virtual machine</a></li>
        <li><a href="#bpf-program-and-map-references">BPF Program and Map references</a></li>
        <li><a href="#libbpf--vmlinux">libbpf &amp; vmlinux</a></li>
      </ul>
    </li>
    <li><a href="#basic-helloworld">Basic Helloworld</a>
      <ul>
        <li><a href="#hash-table-map">Hash Table Map</a></li>
        <li><a href="#ring-buffer-maps">ring buffer maps</a></li>
        <li><a href="#tail-calls">tail calls</a></li>
      </ul>
    </li>
    <li><a href="#simple-xdp-program-in-c">Simple XDP program in C</a></li>
    <li><a href="#bpftool-usage">bpftool usage</a></li>
    <li><a href="#co-re-compile-once-run-everywhere-ebpf-programs">CO-RE (Compile Once, Run Everywhere) eBPF Programs</a></li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><p>eBPF 是一项革命性的技术, 起源于Linux 内核, 它可以在特权上下文中(如操作系统内核)运行沙盒程序. 它用于安全有效地扩展内核的功能, 而无需通过更改内核源代码或加载内核模块的方式来实现. 从历史上看,由于内核具有监督和控制整个系统的特权,操作系统一直是实现可观测性, 安全性和网络功能的理想场所.</p>
<p>对ebpf慕名许久, 正好趁寒假拜读一下Learning eBPF, 虽然是基于略过时的框架bcc, 但是在这个过程中学到的知识想必依旧可以迁移到别的框架去.</p>
<h2 id="background-and-pre-knowledge">Background and pre-knowledge<a hidden class="anchor" aria-hidden="true" href="#background-and-pre-knowledge">#</a></h2>
<h3 id="bcc">bcc<a hidden class="anchor" aria-hidden="true" href="#bcc">#</a></h3>
<p>bcc的ebpf c代码不是真正的C, 而是bcc自己定义的一种和C类似的语言.</p>
<h3 id="limitation-of-ebpf-program">limitation of ebpf program<a hidden class="anchor" aria-hidden="true" href="#limitation-of-ebpf-program">#</a></h3>
<ul>
<li>eBPF 程序必须被验证器校验通过后才能执行，且不能包含无法到达的指令；</li>
<li>eBPF 程序不能随意调用内核函数，只能调用在 API 中定义的辅助函数；</li>
<li>eBPF 程序栈空间最多只有 512 字节，想要更大的存储，就必须要借助映射存储；</li>
<li>在内核 5.2 之前，eBPF 字节码最多只支持 4096 条指令，而 5.2 内核把这个限制提高到了 100 万条；</li>
<li>由于内核的快速变化，在不同版本内核中运行时，需要访问内核数据结构的 eBPF 程序很可能需要调整源码，并重新编译。</li>
</ul>
<h3 id="tracepoint-and-kprobe">tracepoint and kprobe<a hidden class="anchor" aria-hidden="true" href="#tracepoint-and-kprobe">#</a></h3>
<p>tracepoint其实就是在Linux内核的一些关键函数中埋下的hook点,这样在tracing的时候,我们就可以在这些固定的点上挂载调试的函数,然后查看内核的信息.</p>
<p>Tracepoint是在内核中固定的hook点, 并不是在所有的函数中都有tracepoint. 这时候, 我们就需要用到kprobe了. kprobe可以动态地在所有的内核函数(除了inline函数)上挂载probe函数</p>
<h3 id="ebpf-virtual-machine">eBPF virtual machine<a hidden class="anchor" aria-hidden="true" href="#ebpf-virtual-machine">#</a></h3>
<p>The ebpf virtual machine uses 10 general-purpose registers (0-9), and additional register 10 which was used as a stack frame pointer (can only be read but not written). As a BPF program is executed, <strong>values get stored in these registers to keep track of state.</strong></p>
<p>eBPF uses a JIT compiler to convert eBPF bytecode to machine code that runs natively on the target CPU .</p>
<h3 id="bpf-program-and-map-references">BPF Program and Map references<a hidden class="anchor" aria-hidden="true" href="#bpf-program-and-map-references">#</a></h3>
<p>Loading a BPF program into kernel returns a file descriptor, which is a reference to the program and is owned by userspace process. When that process exits, the file descriptor gets released. When there are no references left to BPF program, the kernel removes the program.</p>
<p><code>bpftool</code> will <strong>pin</strong> the program to the filesystem, which creates additional descriptor and the program won&rsquo;t exit even if <code>bpftool</code> exits.</p>
<h3 id="libbpf--vmlinux">libbpf &amp; vmlinux<a hidden class="anchor" aria-hidden="true" href="#libbpf--vmlinux">#</a></h3>
<p><code>vmlinux.h</code> is drived from the kernel source headers, which includes any kernel data structures or type, and is necessary for eBPF program so that you dont have to write definitions for types like u32, u64 by hand.</p>
<p>to use any BPF helper functions, it&rsquo;s needed to include header files from <code>libbpf</code>, which includes the definitions of helper functions and is also needed in <strong>both user space and eBPF C code</strong>.</p>
<h2 id="basic-helloworld">Basic Helloworld<a hidden class="anchor" aria-hidden="true" href="#basic-helloworld">#</a></h2>
<h3 id="hash-table-map">Hash Table Map<a hidden class="anchor" aria-hidden="true" href="#hash-table-map">#</a></h3>
<p>Hash Table Map is an highly useful data struction which could be accessed by ebpf program or userspace program.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e">#!/usr/bin/python</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> bcc <span style="color:#f92672">import</span> BPF
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> time <span style="color:#f92672">import</span> sleep
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>program_hello_map <span style="color:#f92672">=</span> <span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">// define a hash table to store counter data.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">BPF_HASH(counter_table);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">int hello(void *ctx) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    u64 uid;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    u64 counter = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    u64 *p;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    // a ebpf helper function to obtain uid of current process
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    uid = bpf_get_current_uid_gid() &amp; 0xFFFFFFFF;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    // update hashtable
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    p = counter_table.lookup(&amp;uid);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    if (p != 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        counter = *p;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    counter ++;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    counter_table.update(&amp;uid, &amp;counter);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>b <span style="color:#f92672">=</span> BPF(text<span style="color:#f92672">=</span>program_hello_map)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># execve is only an interface in linux kernel, </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># the specific function names vary across different architectures,</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># thus we should find the function name before attaching it.</span>
</span></span><span style="display:flex;"><span>syscall <span style="color:#f92672">=</span> b<span style="color:#f92672">.</span>get_syscall_fnname(<span style="color:#e6db74">&#34;execve&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># attach to execve syscall</span>
</span></span><span style="display:flex;"><span>b<span style="color:#f92672">.</span>attach_kprobe(event<span style="color:#f92672">=</span>syscall, fn_name<span style="color:#f92672">=</span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;hello&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>    sleep(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>    s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># read from hash table</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> k,v <span style="color:#f92672">in</span> b[<span style="color:#e6db74">&#34;counter_table&#34;</span>]<span style="color:#f92672">.</span>items():
</span></span><span style="display:flex;"><span>        s <span style="color:#f92672">+=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;ID: </span><span style="color:#e6db74">{</span>k<span style="color:#f92672">.</span>value<span style="color:#e6db74">}</span><span style="color:#e6db74"> - </span><span style="color:#e6db74">{</span>v<span style="color:#f92672">.</span>value<span style="color:#e6db74">}</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>    print(s)
</span></span></code></pre></div><h3 id="ring-buffer-maps">ring buffer maps<a hidden class="anchor" aria-hidden="true" href="#ring-buffer-maps">#</a></h3>
<p>Ring buffer consists of a buffer, a pointer for written, and pointer for read. The access of data depend on the movement of these two pointers. When a element was read out, the others didn&rsquo;t need to change its location. Data writing may overwrite data that has not been read in a timely manner, which is permissible in some scenarios.</p>
<p><img loading="lazy" src="/images/tech-learning-ebpf/ring-buffer.png" alt="ringbuffer"  />
</p>
<p>The hello world example using ring buffer in book:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> bcc <span style="color:#f92672">import</span> BPF
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>bpf_code <span style="color:#f92672">=</span> <span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">BPF_RINGBUF_OUTPUT(output,1);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">struct data_t {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    int pid;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    int uid;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    char command[16];
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    char message[12];
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">};
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">int hello(void *ctx) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    struct data_t data = </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    char message[] = &#34;Hello, perf_event!&#34;;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    data.pid = bpf_get_current_pid_tgid() &gt;&gt; 32;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    data.uid = bpf_get_current_uid_gid() &amp; 0xFFFFFFFF;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    bpf_get_current_comm(&amp;data.command, sizeof(data.command));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    bpf_probe_read_kernel(&amp;data.message, sizeof(data.message), message);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    // write data into ring buffer
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    output.ringbuf_output(&amp;data, sizeof(data), 0);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>b <span style="color:#f92672">=</span> BPF(text<span style="color:#f92672">=</span>bpf_code)
</span></span><span style="display:flex;"><span>syscall <span style="color:#f92672">=</span> b<span style="color:#f92672">.</span>get_syscall_fnname(<span style="color:#e6db74">&#34;execve&#34;</span>)
</span></span><span style="display:flex;"><span>b<span style="color:#f92672">.</span>attach_kprobe(event<span style="color:#f92672">=</span>syscall, fn_name<span style="color:#f92672">=</span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;hello&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">print_event</span>(cpu, data, size):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># generate the data structure from C declaration automatically</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># This conversion allows the Python program to access the fields (pid, uid, command, message) of the data_t structure as attributes of the data object in Python.</span>
</span></span><span style="display:flex;"><span>    data <span style="color:#f92672">=</span> b[<span style="color:#e6db74">&#34;output&#34;</span>]<span style="color:#f92672">.</span>event(data)
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>data<span style="color:#f92672">.</span>pid<span style="color:#e6db74">}</span><span style="color:#e6db74"> </span><span style="color:#e6db74">{</span>data<span style="color:#f92672">.</span>uid<span style="color:#e6db74">}</span><span style="color:#e6db74"> </span><span style="color:#e6db74">{</span>data<span style="color:#f92672">.</span>command<span style="color:#f92672">.</span>decode()<span style="color:#e6db74">}</span><span style="color:#e6db74"> </span><span style="color:#e6db74">{</span>data<span style="color:#f92672">.</span>message<span style="color:#f92672">.</span>decode()<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># callback function after reading data</span>
</span></span><span style="display:flex;"><span>b[<span style="color:#e6db74">&#34;output&#34;</span>]<span style="color:#f92672">.</span>open_ring_buffer(print_event)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># read from ring buffer, every execution will trigger callback function print_event</span>
</span></span><span style="display:flex;"><span>    b<span style="color:#f92672">.</span>ring_buffer_poll()
</span></span></code></pre></div><p><strong>Ring buffers are preferred over perf buffers for performance reasons, here is the difference in example code</strong></p>
<p><img loading="lazy" src="/images/tech-learning-epbf/perf-ring-diff.png" alt="differences between ring buffers and perf buffers in code"  />
</p>
<h3 id="tail-calls">tail calls<a hidden class="anchor" aria-hidden="true" href="#tail-calls">#</a></h3>
<p>bpf_tail_call 是一个 eBPF 提供的机制, 它允许一个 eBPF 程序调用另一个 eBPF 程序, 类似于函数调用. 然而, 与传统的函数调用不同, bpf_tail_call 实际上是将当前程序替换为另一个程序, 而不是创建一个新的函数调用栈帧. 这意味着被调用的程序(尾调用程序)会接管当前程序的执行上下文, 并且当尾调用程序开始执行时, 原始程序的执行就结束了.</p>
<p>bpf的栈帧空间只有512字节. tail call的通用目的是为了避免当函数递归调用时,栈帧无限地增加(这会导致栈溢出)</p>
<p><img loading="lazy" src="/images/tech-learning-ebpf/function-call.png" alt="一个正常的函数调用过程"  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> bcc <span style="color:#f92672">import</span> BPF
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> ctypes <span style="color:#66d9ef">as</span> ct
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>bpf_code <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">// define maps of type BPF_MAP_TYPE_PROG_ARRAY
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">BPF_PROG_ARRAY(syscall, 300);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">int hello(struct bpf_raw_tracepoint_args *ctx) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    // get opcode of syscall
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    int opcode = ctx-&gt;args[1];
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    // different tail call according to opcode
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    // This line will be replaced with bpf_tail_call() helper function by bcc bofore compiling.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    syscall.call(ctx, opcode);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    // If there is no matched program, then continue execution.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    bpf_trace_printk(&#34;Another syscall: </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;, opcode);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">int hello_exec(void *ctx) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    bpf_trace_printk(&#34;execve syscall&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">int hello_timer(struct bpf_raw_tracepoint_args *ctx) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    if (ctx-&gt;args[1] == 222) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        bpf_trace_printk(&#34;Create a timer&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    } else if (ctx-&gt;args[1] == 226) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        bpf_trace_printk(&#34;Delete a timer&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        bpf_trace_printk(&#34;Aome other timer opration&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">int ignore_opcode(void *ctx) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>b <span style="color:#f92672">=</span> BPF(text<span style="color:#f92672">=</span>bpf_code)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># This time, we attach ebpf program to tracepoint named sys_enter rather than a kprobe</span>
</span></span><span style="display:flex;"><span>b<span style="color:#f92672">.</span>attach_raw_tracepoint(tp<span style="color:#f92672">=</span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;sys_enter&#34;</span>, fn_name<span style="color:#f92672">=</span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;hello&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Get file descriptors of functions</span>
</span></span><span style="display:flex;"><span>ignore_fn <span style="color:#f92672">=</span> b<span style="color:#f92672">.</span>load_func(<span style="color:#e6db74">&#34;ignore_opcode&#34;</span>, BPF<span style="color:#f92672">.</span>RAW_TRACEPOINT)
</span></span><span style="display:flex;"><span>exec_fn <span style="color:#f92672">=</span> b<span style="color:#f92672">.</span>load_func(<span style="color:#e6db74">&#34;hello_exec&#34;</span>, BPF<span style="color:#f92672">.</span>RAW_TRACEPOINT)
</span></span><span style="display:flex;"><span>timer_fn <span style="color:#f92672">=</span> b<span style="color:#f92672">.</span>load_func(<span style="color:#e6db74">&#34;hello_timer&#34;</span>, BPF<span style="color:#f92672">.</span>RAW_TRACEPOINT)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>prog_array <span style="color:#f92672">=</span> b<span style="color:#f92672">.</span>get_table(<span style="color:#e6db74">&#34;syscall&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># put descriptors into map of syscalls</span>
</span></span><span style="display:flex;"><span>prog_array[ct<span style="color:#f92672">.</span>c_int(<span style="color:#ae81ff">59</span>)] <span style="color:#f92672">=</span> ct<span style="color:#f92672">.</span>c_int(exec_fn<span style="color:#f92672">.</span>fd)
</span></span><span style="display:flex;"><span>prog_array[ct<span style="color:#f92672">.</span>c_int(<span style="color:#ae81ff">222</span>)] <span style="color:#f92672">=</span> ct<span style="color:#f92672">.</span>c_int(timer_fn<span style="color:#f92672">.</span>fd)
</span></span><span style="display:flex;"><span>prog_array[ct<span style="color:#f92672">.</span>c_int(<span style="color:#ae81ff">223</span>)] <span style="color:#f92672">=</span> ct<span style="color:#f92672">.</span>c_int(timer_fn<span style="color:#f92672">.</span>fd)
</span></span><span style="display:flex;"><span>prog_array[ct<span style="color:#f92672">.</span>c_int(<span style="color:#ae81ff">224</span>)] <span style="color:#f92672">=</span> ct<span style="color:#f92672">.</span>c_int(timer_fn<span style="color:#f92672">.</span>fd)
</span></span><span style="display:flex;"><span>prog_array[ct<span style="color:#f92672">.</span>c_int(<span style="color:#ae81ff">225</span>)] <span style="color:#f92672">=</span> ct<span style="color:#f92672">.</span>c_int(timer_fn<span style="color:#f92672">.</span>fd)
</span></span><span style="display:flex;"><span>prog_array[ct<span style="color:#f92672">.</span>c_int(<span style="color:#ae81ff">226</span>)] <span style="color:#f92672">=</span> ct<span style="color:#f92672">.</span>c_int(timer_fn<span style="color:#f92672">.</span>fd)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Ignore some syscalls that come up a lot</span>
</span></span><span style="display:flex;"><span>prog_array[ct<span style="color:#f92672">.</span>c_int(<span style="color:#ae81ff">21</span>)] <span style="color:#f92672">=</span> ct<span style="color:#f92672">.</span>c_int(ignore_fn<span style="color:#f92672">.</span>fd)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ......</span>
</span></span><span style="display:flex;"><span>prog_array[ct<span style="color:#f92672">.</span>c_int(<span style="color:#ae81ff">291</span>)] <span style="color:#f92672">=</span> ct<span style="color:#f92672">.</span>c_int(ignore_fn<span style="color:#f92672">.</span>fd)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>b<span style="color:#f92672">.</span>trace_print()
</span></span></code></pre></div><h2 id="simple-xdp-program-in-c">Simple XDP program in C<a hidden class="anchor" aria-hidden="true" href="#simple-xdp-program-in-c">#</a></h2>
<p>Bcc provide a convenient way to write and run ebpf program, however, it would be better to dive deeply in order to have better understand. So, here is a XDP program written in C.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/bpf.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bpf/bpf_helpers.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> counter <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// define that this is an eXpress Data Path (XDP) program
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">SEC</span>(<span style="color:#e6db74">&#34;xdp&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hello</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ctx) {
</span></span><span style="display:flex;"><span>	counter<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// same as bpf_trace_printk() in bcc, both of them are wrappers around kernel function `bpf_trace_printk` 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">bpf_printk</span>(<span style="color:#e6db74">&#34;Helloworld %d&#34;</span>, counter);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> XDP_PASS;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// define license for this program
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> _license[] <span style="color:#a6e22e">SEC</span>(<span style="color:#e6db74">&#34;license&#34;</span>) <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;GPL&#34;</span>;
</span></span></code></pre></div><p>This program do nothing but print variable <code>count</code> everytime the XDP event been triggered, which means a network packet arrives inbound on a network interface.</p>
<p>After writting, we need to compile and load it.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e"># compile, here we got the bytecode of the program</span>
</span></span><span style="display:flex;"><span>clang -O2 -target bpf -c hello.bpf.c -o hello.bpf.o
</span></span><span style="display:flex;"><span><span style="color:#75715e"># load program into kernel, here the bytecode will be transformed to machine code.</span>
</span></span><span style="display:flex;"><span>bpftool prog load hello.bpf.o /sys/fs/bpf/hello
</span></span><span style="display:flex;"><span><span style="color:#75715e"># inspect the loaded program</span>
</span></span><span style="display:flex;"><span>bpftool prog list
</span></span><span style="display:flex;"><span>bpftool prog show id <span style="color:#ae81ff">95</span> --pretty
</span></span><span style="display:flex;"><span>bpftool prog show name hello
</span></span><span style="display:flex;"><span><span style="color:#75715e"># attach to XDP event on a network interface</span>
</span></span><span style="display:flex;"><span>bpftool net attach xdp id <span style="color:#ae81ff">95</span> dev enp0s31f6
</span></span><span style="display:flex;"><span><span style="color:#75715e"># check the program</span>
</span></span><span style="display:flex;"><span>bpftool net list
</span></span><span style="display:flex;"><span><span style="color:#75715e"># check the output</span>
</span></span><span style="display:flex;"><span>cat /sys/kernel/debug/tracing/trace_pipe
</span></span><span style="display:flex;"><span><span style="color:#75715e"># check the global variable counter</span>
</span></span><span style="display:flex;"><span>bpftool map dump name hello.bss
</span></span><span style="display:flex;"><span><span style="color:#75715e"># detach the program</span>
</span></span><span style="display:flex;"><span>bpftool net detach xdp dev enp0s31f6
</span></span></code></pre></div><h2 id="bpftool-usage">bpftool usage<a hidden class="anchor" aria-hidden="true" href="#bpftool-usage">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e"># load program into kernel</span>
</span></span><span style="display:flex;"><span>bpftool prog load hello.bpf.o /sys/fs/bpf/hello
</span></span><span style="display:flex;"><span><span style="color:#75715e"># inspect the loaded program</span>
</span></span><span style="display:flex;"><span>bpftool prog list
</span></span><span style="display:flex;"><span>bpftool prog show id <span style="color:#ae81ff">95</span> --pretty
</span></span><span style="display:flex;"><span>bpftool prog show name hello
</span></span><span style="display:flex;"><span><span style="color:#75715e"># attach to XDP event on a network interface</span>
</span></span><span style="display:flex;"><span>bpftool net attach xdp id <span style="color:#ae81ff">95</span> dev enp0s31f6
</span></span><span style="display:flex;"><span><span style="color:#75715e"># check the program</span>
</span></span><span style="display:flex;"><span>bpftool net list
</span></span><span style="display:flex;"><span><span style="color:#75715e"># check the global variable counter</span>
</span></span><span style="display:flex;"><span>bpftool map dump name hello.bss
</span></span><span style="display:flex;"><span><span style="color:#75715e"># detach the program</span>
</span></span><span style="display:flex;"><span>bpftool net detach xdp dev enp0s31f6
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># list btf (bpf type format)</span>
</span></span><span style="display:flex;"><span>bpftool btf list
</span></span><span style="display:flex;"><span><span style="color:#75715e"># inspect  the contents of BTF information</span>
</span></span><span style="display:flex;"><span>bpftool btf dump id <span style="color:#ae81ff">251</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># generate header file from BTF information</span>
</span></span><span style="display:flex;"><span>bpftool btf dump file /sys/kernel/btf/vmlinux format c &gt; vmlinux.h
</span></span></code></pre></div><h2 id="co-re-compile-once-run-everywhere-ebpf-programs">CO-RE (Compile Once, Run Everywhere) eBPF Programs<a hidden class="anchor" aria-hidden="true" href="#co-re-compile-once-run-everywhere-ebpf-programs">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;vmlinux.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bpf/bpf_helpers.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bpf/bpf_tracing.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bpf/bpf_core_read.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> message[<span style="color:#ae81ff">12</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hello World&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">__uint</span>(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">__uint</span>(key_size, <span style="color:#66d9ef">sizeof</span>(u32));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">__uint</span>(value_size, <span style="color:#66d9ef">sizeof</span>(u32));
</span></span><span style="display:flex;"><span>} output <span style="color:#a6e22e">SEC</span>(<span style="color:#e6db74">&#34;.maps&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#66d9ef">data_t</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">int</span> pid;
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">int</span> uid;
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">char</span> command[<span style="color:#ae81ff">16</span>];
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">char</span> message[<span style="color:#ae81ff">12</span>];
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">char</span> path[<span style="color:#ae81ff">16</span>];
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#66d9ef">user_msg_t</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> message[<span style="color:#ae81ff">12</span>];
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// This structure is used to define the map, not map itself
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// however, my_config can be the map&#39;s reference
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">__uint</span>(type, BPF_MAP_TYPE_HASH);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">__uint</span>(max_entries, <span style="color:#ae81ff">10240</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">__type</span>(key, u32);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">__type</span>(value, <span style="color:#66d9ef">struct</span> <span style="color:#66d9ef">user_msg_t</span>);
</span></span><span style="display:flex;"><span>} my_config <span style="color:#a6e22e">SEC</span>(<span style="color:#e6db74">&#34;.maps&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Tells the loader to attach to the program to the kprobe in the execve syscall
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// BPF_KPROBE_SYSCALL is a macro that expands to the correct BPF program type
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// The first argument is the name of the program: hello
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// The second argument is the executable pathname for execve syscall
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">SEC</span>(<span style="color:#e6db74">&#34;ksyscall/execve&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">BPF_KPROBE_SYSCALL</span>(hello, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>pathname) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#66d9ef">data_t</span> data <span style="color:#f92672">=</span> {};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#66d9ef">user_msg_t</span> <span style="color:#f92672">*</span>p;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    data.pid <span style="color:#f92672">=</span> <span style="color:#a6e22e">bpf_get_current_pid_tgid</span>() <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">32</span>;
</span></span><span style="display:flex;"><span>    data.uid <span style="color:#f92672">=</span> <span style="color:#a6e22e">bpf_get_current_uid_gid</span>() <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xFFFFFFFF</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">bpf_get_current_comm</span>(<span style="color:#f92672">&amp;</span>data.command, <span style="color:#66d9ef">sizeof</span>(data.command));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">bpf_probe_read_user_str</span>(<span style="color:#f92672">&amp;</span>data.path, <span style="color:#66d9ef">sizeof</span>(data.path), pathname);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// my_config is the map&#39;s reference
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    p <span style="color:#f92672">=</span> <span style="color:#a6e22e">bpf_map_lookup_elem</span>(<span style="color:#f92672">&amp;</span>my_config, <span style="color:#f92672">&amp;</span>data.uid);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (p <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">bpf_probe_read_kernel_str</span>(<span style="color:#f92672">&amp;</span>data.message, <span style="color:#66d9ef">sizeof</span>(data.message),
</span></span><span style="display:flex;"><span>                                  p<span style="color:#f92672">-&gt;</span>message);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">bpf_probe_read_kernel_str</span>(<span style="color:#f92672">&amp;</span>data.message, <span style="color:#66d9ef">sizeof</span>(data.message), message);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// submit the data to the user space
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">bpf_perf_event_output</span>(ctx, <span style="color:#f92672">&amp;</span>output, BPF_F_CURRENT_CPU, <span style="color:#f92672">&amp;</span>data, <span style="color:#66d9ef">sizeof</span>(data));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> LICENSE[] <span style="color:#a6e22e">SEC</span>(<span style="color:#e6db74">&#34;license&#34;</span>) <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Dual BSD/GPL&#34;</span>;
</span></span></code></pre></div><p>The <code>Makefile</code></p>
<pre tabindex="0"><code>TARGET = hello-buffer-config
ARCH = $(shell uname -m | sed &#39;s/x86_64/x86/&#39; | sed &#39;s/aarch64/arm64/&#39;)

BPF_OBJ = ${TARGET:=.bpf.o}
USER_C = ${TARGET:=.c}
USER_SKEL = ${TARGET:=.skel.h}

all: $(TARGET) $(BPF_OBJ) find-map
.PHONY: all 

$(TARGET): $(USER_C) $(USER_SKEL) 
	gcc -Wall -o $(TARGET) $(USER_C) -L../libbpf/src -l:libbpf.a -lelf -lz

%.bpf.o: %.bpf.c vmlinux.h
	clang \
	    -target bpf \
        -D __TARGET_ARCH_$(ARCH) \
	    -Wall \
	    -O2 -g -o $@ -c $&lt;

$(USER_SKEL): $(BPF_OBJ)
	bpftool gen skeleton $&lt; &gt; $@

vmlinux.h:
	bpftool btf dump file /sys/kernel/btf/vmlinux format c &gt; vmlinux.h

clean:
	- rm $(BPF_OBJ)
	- rm $(TARGET)
	- rm find-map

find-map: find-map.c
	gcc -Wall -o find-map find-map.c -L../libbpf/src -l:libbpf.a -lelf -lz
</code></pre><p>load:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>bpftool prog load hello.bpf.o /sys/fs/bpf/hello
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="http://ch3n9w.cpolar.cn/posts/gossip-2023-summary/">
    <span class="title">« Prev</span>
    <br>
    <span>2023年度总结</span>
  </a>
  <a class="next" href="http://ch3n9w.cpolar.cn/posts/gossip-rip-clash/">
    <span class="title">Next »</span>
    <br>
    <span>RIP Clash</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="http://ch3n9w.cpolar.cn/">ch3n9w の 超元域</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
