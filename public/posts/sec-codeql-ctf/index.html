<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>CodeQL CTF 之 Go and don&#39;t return | ch3n9w の 超元域</title>
<meta name="keywords" content="">
<meta name="description" content="Go and don&rsquo;t return
这道题目从MinIO的一个已公开的未授权访问漏洞开始, 通过编写并慢慢完善CodeQL语句来检测该漏洞在代码中的位置. 随着题目的进行, 题目将目标将扩展到此类漏洞的各种变种, 难度逐渐加深, 非常适合用来入门和学习. 本文是用来记录我在阅读官方题解时的思考过程, 因为我在Part2就卡住啦hhhhhhh.
🔗原题目链接
🔗官方参考题解链接
在开始之前, 可以查看一下该漏洞的细节 和 描述, 发现该漏洞的原理其实十分简单, 就是在 if s3Err != ErrNone 判断之后没有将不合法的控制流返回, 而是任由它继续进入接下去的claims, s3Err := checkClaimsFromToken(r, cred), 导致校验失败.
具体的漏洞利用可以看这里
Part 1: Let’s catch the bug!
1.1: Finding references to ErrNone

Write the query that finds all identifiers named ErrNone. You will find in the documentation the relevant object types to query. Your query should return 231 results.


import go

from Ident i
where i.getName() = &#34;ErrNone&#34; //Ident就是标识符
select i
运行后就可以检索出ErrNone出现过的所有位置.">
<meta name="author" content="ch3n9w">
<link rel="canonical" href="https://dragonbox.top/posts/sec-codeql-ctf/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://dragonbox.top/flash.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://dragonbox.top/flash.ico">
<link rel="icon" type="image/png" sizes="32x32" href="https://dragonbox.top/flash.ico">
<link rel="apple-touch-icon" href="https://dragonbox.top/flash.ico">
<link rel="mask-icon" href="https://dragonbox.top/flash.ico">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://dragonbox.top/posts/sec-codeql-ctf/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="CodeQL CTF 之 Go and don&#39;t return" />
<meta property="og:description" content="Go and don&rsquo;t return
这道题目从MinIO的一个已公开的未授权访问漏洞开始, 通过编写并慢慢完善CodeQL语句来检测该漏洞在代码中的位置. 随着题目的进行, 题目将目标将扩展到此类漏洞的各种变种, 难度逐渐加深, 非常适合用来入门和学习. 本文是用来记录我在阅读官方题解时的思考过程, 因为我在Part2就卡住啦hhhhhhh.
🔗原题目链接
🔗官方参考题解链接
在开始之前, 可以查看一下该漏洞的细节 和 描述, 发现该漏洞的原理其实十分简单, 就是在 if s3Err != ErrNone 判断之后没有将不合法的控制流返回, 而是任由它继续进入接下去的claims, s3Err := checkClaimsFromToken(r, cred), 导致校验失败.
具体的漏洞利用可以看这里
Part 1: Let’s catch the bug!
1.1: Finding references to ErrNone

Write the query that finds all identifiers named ErrNone. You will find in the documentation the relevant object types to query. Your query should return 231 results.


import go

from Ident i
where i.getName() = &#34;ErrNone&#34; //Ident就是标识符
select i
运行后就可以检索出ErrNone出现过的所有位置." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://dragonbox.top/posts/sec-codeql-ctf/" />
<meta property="og:image" content="https://dragonbox.top/cover.png" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-12-06T09:03:06+08:00" />
<meta property="article:modified_time" content="2024-12-06T09:03:06+08:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://dragonbox.top/cover.png" />
<meta name="twitter:title" content="CodeQL CTF 之 Go and don&#39;t return"/>
<meta name="twitter:description" content="Go and don&rsquo;t return
这道题目从MinIO的一个已公开的未授权访问漏洞开始, 通过编写并慢慢完善CodeQL语句来检测该漏洞在代码中的位置. 随着题目的进行, 题目将目标将扩展到此类漏洞的各种变种, 难度逐渐加深, 非常适合用来入门和学习. 本文是用来记录我在阅读官方题解时的思考过程, 因为我在Part2就卡住啦hhhhhhh.
🔗原题目链接
🔗官方参考题解链接
在开始之前, 可以查看一下该漏洞的细节 和 描述, 发现该漏洞的原理其实十分简单, 就是在 if s3Err != ErrNone 判断之后没有将不合法的控制流返回, 而是任由它继续进入接下去的claims, s3Err := checkClaimsFromToken(r, cred), 导致校验失败.
具体的漏洞利用可以看这里
Part 1: Let’s catch the bug!
1.1: Finding references to ErrNone

Write the query that finds all identifiers named ErrNone. You will find in the documentation the relevant object types to query. Your query should return 231 results.


import go

from Ident i
where i.getName() = &#34;ErrNone&#34; //Ident就是标识符
select i
运行后就可以检索出ErrNone出现过的所有位置."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://dragonbox.top/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "CodeQL CTF 之 Go and don't return",
      "item": "https://dragonbox.top/posts/sec-codeql-ctf/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "CodeQL CTF 之 Go and don't return",
  "name": "CodeQL CTF 之 Go and don\u0027t return",
  "description": "Go and don\u0026rsquo;t return 这道题目从MinIO的一个已公开的未授权访问漏洞开始, 通过编写并慢慢完善CodeQL语句来检测该漏洞在代码中的位置. 随着题目的进行, 题目将目标将扩展到此类漏洞的各种变种, 难度逐渐加深, 非常适合用来入门和学习. 本文是用来记录我在阅读官方题解时的思考过程, 因为我在Part2就卡住啦hhhhhhh.\n🔗原题目链接\n🔗官方参考题解链接\n在开始之前, 可以查看一下该漏洞的细节 和 描述, 发现该漏洞的原理其实十分简单, 就是在 if s3Err != ErrNone 判断之后没有将不合法的控制流返回, 而是任由它继续进入接下去的claims, s3Err := checkClaimsFromToken(r, cred), 导致校验失败.\n具体的漏洞利用可以看这里\nPart 1: Let’s catch the bug! 1.1: Finding references to ErrNone Write the query that finds all identifiers named ErrNone. You will find in the documentation the relevant object types to query. Your query should return 231 results.\nimport go from Ident i where i.getName() = \u0026#34;ErrNone\u0026#34; //Ident就是标识符 select i 运行后就可以检索出ErrNone出现过的所有位置.\n",
  "keywords": [
    
  ],
  "articleBody": "Go and don’t return 这道题目从MinIO的一个已公开的未授权访问漏洞开始, 通过编写并慢慢完善CodeQL语句来检测该漏洞在代码中的位置. 随着题目的进行, 题目将目标将扩展到此类漏洞的各种变种, 难度逐渐加深, 非常适合用来入门和学习. 本文是用来记录我在阅读官方题解时的思考过程, 因为我在Part2就卡住啦hhhhhhh.\n🔗原题目链接\n🔗官方参考题解链接\n在开始之前, 可以查看一下该漏洞的细节 和 描述, 发现该漏洞的原理其实十分简单, 就是在 if s3Err != ErrNone 判断之后没有将不合法的控制流返回, 而是任由它继续进入接下去的claims, s3Err := checkClaimsFromToken(r, cred), 导致校验失败.\n具体的漏洞利用可以看这里\nPart 1: Let’s catch the bug! 1.1: Finding references to ErrNone Write the query that finds all identifiers named ErrNone. You will find in the documentation the relevant object types to query. Your query should return 231 results.\nimport go from Ident i where i.getName() = \"ErrNone\" //Ident就是标识符 select i 运行后就可以检索出ErrNone出现过的所有位置.\n1.2: Finding equality tests against ErrNone In this next step, write a query to find all equality test expressions where one of the operands is an identifier called ErrNone. Your query should give you 158 results.\nimport go from EqualityTestExpr e where e.getAnOperand().(Ident).getName() = \"ErrNone\" select e EqualityTestExpr是一个等式测试, 为==或!=, 它是一个Expression.\n在CodeQL中, Expression是能计算为一组值并且具有类型的语句, 比如1+1, \"QL\", [1,2,3,4,5].\n与之对应的是Statement, 例如try语句, if语句等等. statement没有返回值, 而expression是有返回值的.\ne.getAnOperand().(Ident).getName() 这块是先从EqualityTestExpr中获取操作数, 然后进行类型转换后进行查看.\n1.3: Finding if-blocks making such a test Write a query that finds all if statements, where the condition is an equality test similar as found in step 1.2. Your query should give you 133 results.\nimport go from IfStmt s where s.getCond().(EqualityTestExpr).getAnOperand().(Ident).getName() = \"ErrNone\" select s 从之前的EqualityTestExpr替换为了IfStmt, 缩小了范围.\n1.4: Finding return statements Write a query that finds all return statements. Your query should give 10,651 results.\nimport go from ReturnStmt r select r 可以看出来codeql支持识别的statement种类还挺多的.\n1.5: Finding if-blocks without return statements Write a query that finds all if-blocks that don’t contain return statements in their then branch. Your query should return 3541 results. Remember, we are doing baby steps! We just care about the then branch for now!\n要找所有if-block中不包含返回语句的.\nimport go from IfStmt i where not i.getThen().getAStmt() instanceof ReturnStmt select i 这里i.getThen().getAStmt()是从i的then分支中获取一个statement, 按理来说并不确定这个statement是否本应该是返回语句, 毕竟即便存在ReturnStmt, 也可能没有被getAStmt获取到. 然而关键在于这个not, 它和不等于有着完全不同的含义:\nA != B holds if there is a pair of values (one from A and one from B) that are different. not A = B holds if it is not the case that there is a pair of values that are the same. In other words, A and B have no values in common. 至此就比较清楚了\n1.6: Putting it all together Ok, time to find our bug! Combine steps 1.5 and 1.3 and write a query that finds the if-blocks testing for equality to ErrNone with no return. You should get a total of 7 results. Check that the bug we’re looking for is one of them\nimport go from IfStmt i where i.getCond().(EqualityTestExpr).getAnOperand().(Ident).getName() = \"ErrNone\" and not i.getThen().getAStmt() instanceof ReturnStmt select i 将上面的结合就可以了.\n至此, 已经可以检测出携带漏洞特征的if代码所在的位置了.\nPart 2: Improving the precision 上述codeql的查询结果中存在一些误报. 为了减少误报, 考虑使用更精确的数据流分析来检查isReqAuthenticated的返回值.\n2.1: Find conditionals that are fed from calls to isReqAuthenticated Write a data flow configuration that tracks data flowing from any call to isReqAuthenticated to any equality test operand. Your query must select all equality tests – Type: DataFlow::EqualityTestNode – where the operand is a sink of the above configuration.\nThis gives us 64 potentially interesting conditionals to investigate. Note many of them are not direct calls to isReqAuthenticated, instead they test the result of some intermediate function which in turn calls isReqAuthenticated. The CodeQL global data flow analysis feature allows us to detect those.\nimport go class AuthTestConfig extends DataFlow::Configuration { AuthTestConfig() { this = \"auth-test-config\" } override predicate isSource(DataFlow::Node source) { source = any(DataFlow::CallNode cn | cn.getTarget().hasQualifiedName(\"github.com/minio/minio/cmd\", \"isReqAuthenticated\") ).getResult() } override predicate isSink(DataFlow::Node sink) { sink = any(DataFlow::EqualityTestNode n).getAnOperand() } } from AuthTestConfig config, DataFlow::Node sink, DataFlow::EqualityTestNode comparison where config.hasFlow(_, sink) and comparison.getAnOperand() = sink select comparison 哇塞, 是传说中的污点分析! 其实严格意义上不算是, 这个算是数据流跟踪.\nAuthTestConfig定义了数据流配置, 其中isSource和isSink分别定义了污点分析中的数据流起点Source和数据流终点Sink. 这里Source为调用isReqAuthenticated函数的节点, Sink是比较测试节点中的操作数.\n根据文档, any这玩意的用法如下\nany( | | ) 是对variable的要求, 对于每一个满足要求的变量都会返回一个, 如果没有就返回variable本身, 因此可能会返回多个.\n那么问题来了, source或者sink是怎么和any的多个返回值进行比较的呢? 其实答案在文档中已经描述了:\nFor expressions A and B, the formula A = B holds if there is a pair of values—one from A and one from B—that are the same. In other words, A and B have at least one value in common. For example, [1 .. 2] = [2 .. 5] holds, since both expressions have the value 2.\n因此, 根据文档, 1 = [1..2] 是成立的, 那么isSource和isSink中的比较也是成立的.\n最后, config.hasFlow(_, sink) 中将source部分设置为_, 因为我们的查询中并不包含source, 而comparison.getOperand() = sink也是方便去查询出相应的比较测试节点.\n2.2: Find the true bug! We can now put this dataflow query together with our query from step 1.6, and find all if statements that\nAre one of the equality tests returned in 2.1 Are testing equality against ErrNone Do not contain a return statement in their then branch import go class AuthTestConfig extends DataFlow::Configuration { AuthTestConfig() { this = \"auth-test-config\" } override predicate isSource(DataFlow::Node source) { source = any(DataFlow::CallNode cn | cn.getTarget().hasQualifiedName(\"github.com/minio/minio/cmd\", \"isReqAuthenticated\") ).getResult() } override predicate isSink(DataFlow::Node sink) { sink = any(DataFlow::EqualityTestNode n).getAnOperand() } } EqualityTestExpr getAnAuthCheck() { exists(AuthTestConfig config, DataFlow::Node sink, DataFlow::EqualityTestNode comparison | config.hasFlow(_, sink) and comparison.getAnOperand() = sink | result = comparison.asExpr() ) } from IfStmt i where i.getCond() = getAnAuthCheck() and i.getCond().(EqualityTestExpr).getAnOperand().(Ident).getName() = \"ErrNone\" and not i.getThen().getAStmt() instanceof ReturnStmt select i 将之前的部分结合起来就可以了. 这里新出现了一个exists, 其用法为:\nexists( | ) 当存在一个变量使得formula成立, 公式成立, 而formula可以有多个, 即\nexists( | | |...| ) 等价于\nexists( | and and...and ) 如果至少存在一组variables使得全部formula都满足, 那么公式成立.\n而题解中的这种写法, 相当于等前面所有的formula都满足的时候, 临时变量result会被赋值 comparison.asExpr() , 而result又是 getAnAuthCheck 的返回值, 因此就变成: 返回一组满足运算单元是污点源的 EqualityTestExpr.\nPart 3: Expanding the query 这部分要扩大范围, 不再局限于MinIO了, 使用的检测对象是这道题目附带的database.\n3.1: Conditional polarity You might have noticed this in step 1.6: our code looking for equality tests encompases both x == ErrNone and x != ErrNone and checks the then block in both cases. This is wrong. It ought to check the “then” or “else” case of an if block, depending on which form of conditional is used. Modify your query to fix this problem. Your query should be able to detect all bad examples in conditionalPolarities.go. Hint: Check out the predicate EqualityTestExpr.getPolarity\n需要根据x==ErrNone和x!=ErrNone的不同情况进行不同检查.\nimport go class AuthTestConfig extends DataFlow::Configuration { AuthTestConfig() { this = \"auth-test-config\" } override predicate isSource(DataFlow::Node source) { source = any(DataFlow::CallNode cn | cn.getTarget().hasQualifiedName(\"github.com/minio/minio/cmd\", \"isReqAuthenticated\") or // Note new source function: cn.getTarget().hasQualifiedName(\"github.com/github/codeql-ctf-go-return\", \"errorSource\") ).getResult() } override predicate isSink(DataFlow::Node sink) { sink = any(DataFlow::EqualityTestNode n).getAnOperand() } } EqualityTestExpr getADirectAuthCheck(boolean polarity) { exists(AuthTestConfig config, DataFlow::Node sink, DataFlow::EqualityTestNode comparison | config.hasFlow(_, sink) and comparison.getAnOperand() = sink | result = comparison.asExpr() and polarity = result.getPolarity() ) } /** * Given `ifStmt`'s condition compares some `x` against `ErrNone` with `polarity` (true means checking * equality; false checking inequality), return the block reached when `x != ErrNone`. */ BlockStmt getErrorBranch(IfStmt ifStmt, boolean polarity) { polarity = [true, false] and if polarity = true then result = ifStmt.getElse() else result = ifStmt.getThen() } from IfStmt i, boolean testPolarity where i.getCond() = getADirectAuthCheck(testPolarity) and i.getCond().(EqualityTestExpr).getAnOperand().(Ident).getName() = \"ErrNone\" and not getErrorBranch(i, testPolarity).getAStmt() instanceof ReturnStmt select i 重点是if polarity = true then result = ifStmt.getElse() else result = ifStmt.getThen()这一句.\n另外polarity = [true, false]这个是对变量的限制, 在文档中有相关的描述\nIt must be possible to evaluate a predicate in a finite amount of time, so the set it describes is not usually allowed to be infinite. In other words, a predicate can only contain a finite number of tuples.\n如果没有polarity = [true, false], 虽然理论上来说boolean变量也只有两个值, 但是统一起见还是需要做限制.\n3.2: More blocks Let’s detect more blocks that must return. For example, our query fails to detect a return statement in an else branch, and there are other such cases that we need to handle, such as cascading else or switch/case. Modify your query to find more blocks that don’t return. Your query should be able to detect all bad examples in moreWaysToReturn.go. Hints: While we could recursively inspect the control-flow structures inside the if block, it may help to use the control-flow graph. Check the documentation of the class IR::ReturnInstruction, a control-flow graph node corresponding to a return statement, and the getAPredecessor() / getASuccessor() methods of its superclass ControlFlow::Node, which traverse control-flow graph edges. A passing or failing if test is always followed by a ConditionGuardNode that indicates which branch was taken.\nTip: Try creating a temporary query such as the one below to get an idea what the control flow graph looks like.\nfrom ControlFlow::Node pred, ControlFlow::Node succ where succ = pred.getASuccessor() // you can also restrict `pred` to come from a particular source file select pred, succ 要寻找更多分支语句中的没有返回的部分.\nimport go class AuthTestConfig extends DataFlow::Configuration { AuthTestConfig() { this = \"auth-test-config\" } override predicate isSource(DataFlow::Node source) { source = any(DataFlow::CallNode cn | cn.getTarget().hasQualifiedName(\"github.com/minio/minio/cmd\", \"isReqAuthenticated\") or cn.getTarget().hasQualifiedName(\"github.com/github/codeql-ctf-go-return\", \"errorSource\") ).getResult() } override predicate isSink(DataFlow::Node sink) { sink = any(DataFlow::EqualityTestNode n).getAnOperand() } } EqualityTestExpr getAnAuthCheck() { exists(AuthTestConfig config, DataFlow::Node sink, DataFlow::EqualityTestNode comparison | config.hasFlow(_, sink) and comparison.getAnOperand() = sink | result = comparison.asExpr() ) } ReturnStmt getAReturnStatementInBlock(BlockStmt b) { result = b.getAChild*() } predicate mustReachReturnInBlock(ControlFlow::Node node, BlockStmt b) { node.(IR::ReturnInstruction).getReturnStmt() = getAReturnStatementInBlock(b) or forex(ControlFlow::Node succ | succ = node.getASuccessor() | mustReachReturnInBlock(succ, b)) } from IfStmt i, ControlFlow::ConditionGuardNode ifSucc where i.getCond() = getAnAuthCheck() and i.getCond().(EqualityTestExpr).getAnOperand().(Ident).getName() = \"ErrNone\" and ifSucc.ensures(DataFlow::exprNode(i.getCond()), true) and not mustReachReturnInBlock(ifSucc, i.getThen()) select i ifSucc.ensures(DataFlow::exprNode(i.getCond()), true) 涉及到了控制流节点ifSucc, 这条语句的意思是 确保i.getCond()的条件成立, 成立之后才对then分支的语句进行分析.\n关于ConditionGuardNode, 文档中的有直观的实例.\n对于以下代码\nx := 0 if p != nil { x = p.f } return x 其ConditionGuardNode为图中的p != nil is true和p != nil is false.\n当变量调用谓词(predicate)的时候, 如果存在结果, 那么这种调用是一个表达式, 否则就是一个公式. 返回结果的谓词可以在经过逻辑判断后返回多个结果, 例如\nstring getANeighbor(string country) { country = \"France\" and result = \"Belgium\" or country = \"France\" and result = \"Germany\" or country = \"Germany\" and result = \"Austria\" or country = \"Germany\" and result = \"Belgium\" } 对于上述predicate, 如果country为\"Germany\", 那么返回值为Austria和Belgium, 这点和平时用的编程语言区别挺大的.\n同样的, b.getAChild()是一个带结果的谓词调用, 会返回多个子节点.\n接下来是代表闭包传递的*和+, 这两个都有迭代的功能, 例如ReturnStmt getAChild*() 等价于\nReturnStmt getOneChild() { result = this or result = this.getAChild().getOneChild() } 而ReturnStmt getAChild+() 等价于\nReturnStmt getOneChild() { result = this.getAChild() or result = this.getAChild().getOneChild() } 也就是说*相比较+还包含了自身.\n那么getAReturnStatementInBlock的结果就是当前节点加上当前节点经过递归后的所有子节点.\n那么子节点的集合要怎么和node.(IR::ReturnInstruction).getReturnStmt()进行比较? 根据文档中所描述的:\nFor expressions A and B, the formula A = B holds if there is a pair of values—one from A and one from B—that are the same. In other words, A and B have at least one value in common. For example, [1 .. 2] = [2 .. 5] holds, since both expressions have the value 2.\n那么就不难理解了, 只要node.(IR::ReturnInstruction).getReturnStmt()的值和其中一个相同, mustReachReturnInBlock就会成立, 不然就进入forex部分.\nforex的用法, 根据文档, 可以看作是forall 和 exists 的结合. 三者的定义如下\nforall( | | ) forex( | | ) 等价于 forall( | | ) and exists( | | ) forall: 当每一个让formula1 成立的变量在formula2成立的时候, 公式成立 forex: 和forall类似, 但是排除了不存在满足formula1的变量的情况, 因为这种情况下formula2会无条件成立. 那么代码中forex的意思就是: 对于node的successor, 要求successor存在, 并且每一个successor满足mustReachReturnInBlock, 也就是说每一个successor都存在ReturnStmt\n在查阅文档的时候可以注意类的supertypes都有哪些, 包括Direct supertypes 和 Indirect supertypes. 所谓Indirect supertypes就是指, supertype在经历了多次继承之后才能变成该类, 而direct supertypes 是直接继承的. 这些supertypes都可以通过类型转换变成这个类.\n3.3: Wrapped conditionals Now we can have cases where our equality test against ErrNone is no longer directly used in a conditional statement, but is instead wrapped inside a utility function. Modify your query to handle this case. Your query should be able to detect all bad examples in wrapperFunctions.go.\nHint:\nYou can have several layers in your wrap! Check out the predicates CallExpr::getTarget(), DataFlow::CallNode::getTarget() and Function::getFuncDecl() to navigate between a callsite and its callee. 相比较之前的直接查询if语句中的内容, 这里要求额外覆盖使用函数返回值进行判断的情况, 例如\nif succeeded(errorSource()) { doSomething() } else { // Bad: despite an error, we carry on to execute doSomething() insteadOfReturn() } import go class AuthTestConfig extends DataFlow::Configuration { AuthTestConfig() { this = \"auth-test-config\" } override predicate isSource(DataFlow::Node source) { source = any(DataFlow::CallNode cn | cn.getTarget().hasQualifiedName(\"github.com/minio/minio/cmd\", \"isReqAuthenticated\") or // Note new source function: cn.getTarget().hasQualifiedName(\"github.com/github/codeql-ctf-go-return\", \"errorSource\") ).getResult() } override predicate isSink(DataFlow::Node sink) { sink = any(DataFlow::EqualityTestNode n).getAnOperand() } } EqualityTestExpr getADirectAuthCheck(boolean polarity) { exists(AuthTestConfig config, DataFlow::Node sink, DataFlow::EqualityTestNode comparison | config.hasFlow(_, sink) and comparison.getAnOperand() = sink | result = comparison.asExpr() and result.getAnOperand().(Ident).getName() = \"ErrNone\" and polarity = result.getPolarity() ) } CallExpr getACheckCall(boolean polarity, FuncDecl target, Expr innerCheck) { innerCheck = getAnAuthCheck(polarity) and target = result.getTarget().getFuncDecl() and forex(DataFlow::ResultNode rn | rn.getRoot() = target | rn.asExpr() = innerCheck) } Expr getAnAuthCheck(boolean polarity) { result = getADirectAuthCheck(polarity) or result = getACheckCall(polarity, _, _) } /** * Given `ifStmt`'s condition compares some `x` against `ErrNone` with `polarity` (true means checking * equality; false checking inequality), return the block reached when `x != ErrNone`. */ BlockStmt getErrorBranch(IfStmt ifStmt, boolean polarity) { polarity = [true, false] and if polarity = true then result = ifStmt.getElse() else result = ifStmt.getThen() } from IfStmt i, boolean testPolarity where i.getCond() = getAnAuthCheck(testPolarity) and not getErrorBranch(i, testPolarity).getAStmt() instanceof ReturnStmt select i getErrorBranch 没什么好说的, 就是根据polarity选择else分支或者then分支.\n但是getAnAuthCheck就不同了, 这里用到了一个相当高级的写法: 相互递归(Mutal Recursion), 这会形成谓词之间的依赖链条, 可以看文档 给出的一个例子.\nint getAnEven() { result = 0 or result \u003c= 100 and result = getAnOdd() + 1 } int getAnOdd() { result = getAnEven() + 1 } select getAnEven() 在这个例子中getAnEven和getAnOdd之间形成了谓词依赖链条, codeql会持续递归到限制条件后返回0到100的偶数.\ngetAnAuthCheck和getACheckCall之间也存在相互递归的关系. getAnAuthCheck 首先根据polarity的值去选择xxx==ErrNone或xxx!=ErrorNone这两种sink并转化为表达式, 和之前的差不多, 而getACheckCall中, 首先会反过来递归获取getAnAuthCheck的结果.\n定义target为函数的声明, 同时也对CallExpr类型的result作了隐式的定义.\n接下来, forex对每一个DataFlow::ResultNode 进行检查, DataFlow::ResultNode 在文档中描述为:\nThis can either be a node corresponding to an expression in a return statement, or a node representing the current value of a named result variable at the exit of the function.\n而getRoot能够获取节点所属的函数, 这个forex的意思就成为了 要求每一个ResultNode所属的函数都与target代表的函数对应, 同时ResultNode的表达式是getAnAuthCheck的结果, 也就是innerCheck\n那么innerCheck也就是getAnAuthCheck(polarity), 代表的就是条件判断的sink, 以及条件判断中所使用的存在条件判断sink的函数.\n3.4: More conditionals Our code works for simple equality tests, but there are cases where this test is part of a bigger test with conditionals involving !, \u0026\u0026, ||, that are not currently accounted for in our query. Improve your query to handle these cases. Your query should be able to detect all bad examples in logicalOperators.go. Hint: Check out ControlFlow::ConditionGuardNode. This node flags a point in a control-flow graph where a particular test is known to have passed or failed, including those nested within the short-circuiting binary logical operators \u0026\u0026, ||. Its predicate ensures can already analyse some boolean expression structure. Even if you cannot use it directly, the implementation of ensures may be a useful inspiration for your solution. See the hints for Step 3.2 for more information about the control-flow graph.\n也就是说要对!x, x||y, x \u0026\u0026 y, (x) 这些情况进行处理.\nimport go class AuthTestConfig extends DataFlow::Configuration { AuthTestConfig() { this = \"auth-test-config\" } override predicate isSource(DataFlow::Node source) { source = any(DataFlow::CallNode cn | cn.getTarget().hasQualifiedName(\"github.com/minio/minio/cmd\", \"isReqAuthenticated\") or // Note new source function: cn.getTarget().hasQualifiedName(\"github.com/github/codeql-ctf-go-return\", \"errorSource\") ).getResult() } override predicate isSink(DataFlow::Node sink) { sink = any(DataFlow::EqualityTestNode n).getAnOperand() } } EqualityTestExpr getADirectAuthCheck(boolean polarity) { exists(AuthTestConfig config, DataFlow::Node sink, DataFlow::EqualityTestNode comparison | config.hasFlow(_, sink) and comparison.getAnOperand() = sink | result = comparison.asExpr() and polarity = result.getPolarity() ) } Expr getAnAuthCheck(Boolean noError, EqualityTestExpr test) { result = getADirectAuthCheck(noError) and test = result or result.(ParenExpr).getExpr() = getAnAuthCheck(noError, test) or result.(NotExpr).getOperand() = getAnAuthCheck(noError.booleanNot(), test) or result.(LandExpr).getRightOperand() = getAnAuthCheck(noError, test) or result.(LandExpr).getLeftOperand() = getAnAuthCheck(true, test) and noError = true or result.(LandExpr).getLeftOperand() = getAnAuthCheck(false, test) and noError = [true, false] or result.(LorExpr).getRightOperand() = getAnAuthCheck(noError, test) or result.(LorExpr).getLeftOperand() = getAnAuthCheck(false, test) and noError = false or result.(LorExpr).getLeftOperand() = getAnAuthCheck(true, test) and noError = [true, false] } BlockStmt getErrorBranch(IfStmt ifStmt, boolean polarity) { polarity = [true, false] and if polarity = true then result = ifStmt.getElse() else result = ifStmt.getThen() } from IfStmt i, EqualityTestExpr test where test.getAnOperand().(Ident).getName() = \"ErrNone\" and not forall(boolean testPolarity | i.getCond() = getAnAuthCheck(testPolarity, test) | exists(Stmt s | s = getErrorBranch(i, testPolarity).getAStmt() | s instanceof ReturnStmt)) and i.getFile().getBaseName() = \"logicalOperators.go\" select i getAnAuthCheck是重点\n// 使用test来约束直接检查的结果: 必须是有ErrNone参与的等式检查 result = getADirectAuthCheck(noError) and result = test or // 对getAnAuthCheck的结果进行约束, 结果必须为一个ParenExpr中去掉括号的Expr // 如果存在这样的结果, 那么这里的result就满足要求了 result.(ParenExpr).getExpr() = getAnAuthCheck(noError, test) or // 对getAnAuthCheck的结果进行约束, 结果必须为一个NotExpr中去掉Not部分的Expr result.(NotExpr).getOperand() = getAnAuthCheck(noError.booleanNot(), test) 但是接下来的那几个AND和OR相关的处理我就看不懂了, 后续再说吧.\n最后应该说明一下forall和exists的组合使用:\n// 所有满足污点和ErrNone参与的条件检查中, 每一个分支里都存在返回语句 forall(boolean testPolarity | i.getCond() = getAnAuthCheck(testPolarity, test) | // 如果错误分支中存在返回语句, 那么成立 exists(Stmt s | s = getErrorBranch(i, testPolarity).getAStmt() | s instanceof ReturnStmt)) 将上面的逻辑取反, 就变成了 所有满足污点和ErrNone参与的条件检查中, 存在不包含返回语句的分支.\n3.5: Valid returns only Ok, so now we make sure we return something when we check the permission. But is that enough? Just returning somehow isn’t good enough, we may also need to return an appropriate value. The use of non-nil / nil error values is normal to indicate an error in Go, so let’s assume for this problem that non-nil is considered an appropriate return value. Modify your query to detect all bad examples in checkReturnValue.go.\n需要检测那些和ErrNone比较后可能返回nil的情况.\nimport go class AuthTestConfig extends DataFlow::Configuration { AuthTestConfig() { this = \"auth-test-config\" } override predicate isSource(DataFlow::Node source) { source = any(DataFlow::CallNode cn | cn.getTarget().hasQualifiedName(\"github.com/minio/minio/cmd\", \"isReqAuthenticated\") or // Note new source function: cn.getTarget().hasQualifiedName(\"github.com/github/codeql-ctf-go-return\", \"errorSource\") ).getResult() } override predicate isSink(DataFlow::Node sink) { sink = any(DataFlow::EqualityTestNode n).getAnOperand() } } predicate returnsNil(FuncDecl f) { forex(DataFlow::ResultNode r | r.getRoot() = f | r = Builtin::nil().getARead()) } predicate isNil(Expr e) { e = any(CallExpr c | returnsNil(c.getTarget().getFuncDecl())) or e = Builtin::nil().getAReference() } EqualityTestExpr getADirectAuthCheck(boolean polarity) { exists(AuthTestConfig config, DataFlow::Node sink, DataFlow::EqualityTestNode comparison | config.hasFlow(_, sink) and comparison.getAnOperand() = sink | result = comparison.asExpr() and polarity = result.getPolarity() ) } /** * Given `ifStmt`'s condition compares some `x` against `ErrNone` with `polarity` (true means checking * equality; false checking inequality), return the block reached when `x != ErrNone`. */ BlockStmt getErrorBranch(IfStmt ifStmt, boolean polarity) { polarity = [true, false] and if polarity = true then result = ifStmt.getElse() else result = ifStmt.getThen() } from IfStmt i, boolean testPolarity, int resultIdx where i.getCond() = getADirectAuthCheck(testPolarity) and i.getCond().(EqualityTestExpr).getAnOperand().(Ident).getName() = \"ErrNone\" and i.getEnclosingFunction().getType().getResultType(resultIdx) = Builtin::error().getType() and // i 所属函数的返回值类型中有错误类型 not exists(ReturnStmt r | r = getErrorBranch(i, testPolarity).getAStmt() | not isNil(r.getExpr(resultIdx)) ) // 这个错误类型不是nil select i ",
  "wordCount" : "2729",
  "inLanguage": "en",
  "image":"https://dragonbox.top/cover.png","datePublished": "2024-12-06T09:03:06+08:00",
  "dateModified": "2024-12-06T09:03:06+08:00",
  "author":{
    "@type": "Person",
    "name": "ch3n9w"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://dragonbox.top/posts/sec-codeql-ctf/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "ch3n9w の 超元域",
    "logo": {
      "@type": "ImageObject",
      "url": "https://dragonbox.top/flash.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://dragonbox.top/" accesskey="h" title="ch3n9w の 超元域 (Alt + H)">
                <img src="https://dragonbox.top/avatar.jpg" alt="" aria-label="logo"
                    height="35">ch3n9w の 超元域</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://dragonbox.top/categories/" title="categories">
                    <span>categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://dragonbox.top/">Home</a>&nbsp;»&nbsp;<a href="https://dragonbox.top/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      CodeQL CTF 之 Go and don&#39;t return
    </h1>
    <div class="post-meta"><span title='2024-12-06 09:03:06 +0800 CST'>December 6, 2024</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;2729 words&nbsp;·&nbsp;ch3n9w

</div>
  </header> 
<figure class="entry-cover">
        <img loading="eager" srcset="https://dragonbox.top/posts/sec-codeql-ctf/cover_hu18341172239657117764.png 360w ,https://dragonbox.top/posts/sec-codeql-ctf/cover_hu3399689789567156695.png 480w ,https://dragonbox.top/posts/sec-codeql-ctf/cover_hu6462648450707173077.png 720w ,https://dragonbox.top/posts/sec-codeql-ctf/cover_hu196017312278354417.png 1080w ,https://dragonbox.top/posts/sec-codeql-ctf/cover.png 1200w" 
            sizes="(min-width: 768px) 720px, 100vw" src="https://dragonbox.top/posts/sec-codeql-ctf/cover.png" alt="" 
            width="1200" height="630">
        
</figure><div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#part-1-lets-catch-the-bug">Part 1: Let’s catch the bug!</a>
      <ul>
        <li><a href="#11-finding-references-to-errnone">1.1: Finding references to ErrNone</a></li>
        <li><a href="#12-finding-equality-tests-against-errnone">1.2: Finding equality tests against ErrNone</a></li>
        <li><a href="#13-finding-if-blocks-making-such-a-test">1.3: Finding if-blocks making such a test</a></li>
        <li><a href="#14-finding-return-statements">1.4: Finding return statements</a></li>
        <li><a href="#15-finding-if-blocks-without-return-statements">1.5: Finding if-blocks without return statements</a></li>
        <li><a href="#16-putting-it-all-together">1.6: Putting it all together</a></li>
      </ul>
    </li>
    <li><a href="#part-2-improving-the-precision">Part 2: Improving the precision</a>
      <ul>
        <li><a href="#21-find-conditionals-that-are-fed-from-calls-to-isreqauthenticated">2.1: Find conditionals that are fed from calls to isReqAuthenticated</a></li>
        <li><a href="#22-find-the-true-bug">2.2: Find the true bug!</a></li>
      </ul>
    </li>
    <li><a href="#part-3-expanding-the-query">Part 3: Expanding the query</a>
      <ul>
        <li><a href="#31-conditional-polarity">3.1: Conditional polarity</a></li>
        <li><a href="#32-more-blocks">3.2: More blocks</a></li>
        <li><a href="#33-wrapped-conditionals">3.3: Wrapped conditionals</a></li>
        <li><a href="#34-more-conditionals">3.4: More conditionals</a></li>
        <li><a href="#35-valid-returns-only">3.5: Valid returns only</a></li>
      </ul>
    </li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="go-and-dont-return">Go and don&rsquo;t return<a hidden class="anchor" aria-hidden="true" href="#go-and-dont-return">#</a></h1>
<p>这道题目从MinIO的一个已公开的未授权访问漏洞开始, 通过编写并慢慢完善CodeQL语句来检测该漏洞在代码中的位置. 随着题目的进行, 题目将目标将扩展到此类漏洞的各种变种, 难度逐渐加深, 非常适合用来入门和学习. 本文是用来记录我在阅读官方题解时的思考过程, 因为我在Part2就卡住啦hhhhhhh.</p>
<p><a href="https://securitylab.github.com/ctf/go-and-dont-return/">🔗原题目链接</a></p>
<p><a href="https://securitylab.github.com/ctf/go-and-dont-return/answers/">🔗官方参考题解链接</a></p>
<p>在开始之前, 可以查看一下该漏洞的<a href="https://github.com/minio/minio/commit/4cd6ca02c7957aeb2de3eede08b0754332a77923">细节</a> 和 <a href="https://github.com/minio/minio/security/advisories/GHSA-xv4r-vccv-mg4w">描述</a>, 发现该漏洞的原理其实十分简单, 就是在 <code>if s3Err != ErrNone</code> 判断之后没有将不合法的控制流返回, 而是任由它继续进入接下去的<code>claims, s3Err := checkClaimsFromToken(r, cred)</code>, 导致校验失败.</p>
<p>具体的漏洞利用可以看<a href="https://github.com/cokeBeer/go-cves/blob/main/CVE-2020-11012/CVE-2020-11012.md">这里</a></p>
<h2 id="part-1-lets-catch-the-bug">Part 1: Let’s catch the bug!<a hidden class="anchor" aria-hidden="true" href="#part-1-lets-catch-the-bug">#</a></h2>
<h3 id="11-finding-references-to-errnone">1.1: Finding references to ErrNone<a hidden class="anchor" aria-hidden="true" href="#11-finding-references-to-errnone">#</a></h3>
<blockquote>
<p>Write the query that finds all identifiers named ErrNone. You will find in the documentation the relevant object types to query. Your query should return 231 results.</p>
</blockquote>
<pre tabindex="0"><code class="language-ql" data-lang="ql">
import go

from Ident i
where i.getName() = &#34;ErrNone&#34; //Ident就是标识符
select i
</code></pre><p>运行后就可以检索出ErrNone出现过的所有位置.</p>
<h3 id="12-finding-equality-tests-against-errnone">1.2: Finding equality tests against ErrNone<a hidden class="anchor" aria-hidden="true" href="#12-finding-equality-tests-against-errnone">#</a></h3>
<p>In this next step, write a query to find all equality test expressions where one of the operands is an identifier called ErrNone. Your query should give you 158 results.</p>
<pre tabindex="0"><code class="language-ql" data-lang="ql">import go

from EqualityTestExpr e
where e.getAnOperand().(Ident).getName() = &#34;ErrNone&#34;
select e
</code></pre><p><code>EqualityTestExpr</code>是一个等式测试, 为<code>==</code>或<code>!=</code>, 它是一个Expression.</p>
<p>在CodeQL中, Expression是能计算为一组值并且具有类型的语句, 比如<code>1+1</code>, <code>&quot;QL&quot;</code>, <code>[1,2,3,4,5]</code>.</p>
<p>与之对应的是Statement, 例如try语句, if语句等等. <strong>statement没有返回值, 而expression是有返回值的.</strong></p>
<p><code>e.getAnOperand().(Ident).getName()</code> 这块是先从<code>EqualityTestExpr</code>中获取操作数, 然后进行类型转换后进行查看.</p>
<h3 id="13-finding-if-blocks-making-such-a-test">1.3: Finding if-blocks making such a test<a hidden class="anchor" aria-hidden="true" href="#13-finding-if-blocks-making-such-a-test">#</a></h3>
<blockquote>
<p>Write a query that finds all if statements, where the condition is an equality test similar as found in step 1.2. Your query should give you 133 results.</p>
</blockquote>
<pre tabindex="0"><code class="language-ql" data-lang="ql">import go

from IfStmt s
where s.getCond().(EqualityTestExpr).getAnOperand().(Ident).getName() = &#34;ErrNone&#34;
select s
</code></pre><p>从之前的EqualityTestExpr替换为了IfStmt, 缩小了范围.</p>
<h3 id="14-finding-return-statements">1.4: Finding return statements<a hidden class="anchor" aria-hidden="true" href="#14-finding-return-statements">#</a></h3>
<blockquote>
<p>Write a query that finds all return statements. Your query should give 10,651 results.</p>
</blockquote>
<pre tabindex="0"><code class="language-ql" data-lang="ql">import go

from ReturnStmt r
select r
</code></pre><p>可以看出来codeql支持识别的statement种类还挺多的.</p>
<h3 id="15-finding-if-blocks-without-return-statements">1.5: Finding if-blocks without return statements<a hidden class="anchor" aria-hidden="true" href="#15-finding-if-blocks-without-return-statements">#</a></h3>
<blockquote>
<p>Write a query that finds all if-blocks that don’t contain return statements in their then branch. Your query should return 3541 results. Remember, we are doing baby steps! We just care about the then branch for now!</p>
</blockquote>
<p>要找所有if-block中不包含返回语句的.</p>
<pre tabindex="0"><code class="language-ql" data-lang="ql">import go

from IfStmt i
where not i.getThen().getAStmt() instanceof ReturnStmt
select i
</code></pre><p>这里<code>i.getThen().getAStmt()</code>是从i的then分支中获取一个statement, 按理来说并不确定这个statement是否<strong>本应该</strong>是返回语句, 毕竟即便存在ReturnStmt, 也可能没有被<code>getAStmt</code>获取到. 然而关键在于这个<code>not</code>, 它和不等于有着完全不同的含义:</p>
<ul>
<li><code>A != B</code> holds if there is a pair of values (one from A and one from B) that are different.</li>
<li><code>not A = B</code> holds if it is not the case that there is a pair of values that are the same. In other words, <strong>A and B have no values in common</strong>.</li>
</ul>
<p>至此就比较清楚了</p>
<h3 id="16-putting-it-all-together">1.6: Putting it all together<a hidden class="anchor" aria-hidden="true" href="#16-putting-it-all-together">#</a></h3>
<blockquote>
<p>Ok, time to find our bug! Combine steps 1.5 and 1.3 and write a query that finds the if-blocks testing for equality to ErrNone with no return.
You should get a total of 7 results. Check that the bug we&rsquo;re looking for is one of them</p>
</blockquote>
<pre tabindex="0"><code class="language-ql" data-lang="ql">import go

from IfStmt i
where
i.getCond().(EqualityTestExpr).getAnOperand().(Ident).getName() = &#34;ErrNone&#34;
and not i.getThen().getAStmt() instanceof ReturnStmt
select i
</code></pre><p>将上面的结合就可以了.</p>
<p>至此, 已经可以检测出携带漏洞特征的if代码所在的位置了.</p>
<h2 id="part-2-improving-the-precision">Part 2: Improving the precision<a hidden class="anchor" aria-hidden="true" href="#part-2-improving-the-precision">#</a></h2>
<p>上述codeql的查询结果中存在一些误报. 为了减少误报, 考虑使用更精确的数据流分析来检查<code>isReqAuthenticated</code>的返回值.</p>
<p><img loading="lazy" src="./isReqAuthenticated.png" alt="isReqAuthenticated"  />
</p>
<h3 id="21-find-conditionals-that-are-fed-from-calls-to-isreqauthenticated">2.1: Find conditionals that are fed from calls to isReqAuthenticated<a hidden class="anchor" aria-hidden="true" href="#21-find-conditionals-that-are-fed-from-calls-to-isreqauthenticated">#</a></h3>
<blockquote>
<p>Write a data flow configuration that tracks data flowing from any call to isReqAuthenticated to any equality test operand. Your query must select all equality tests &ndash; Type: DataFlow::EqualityTestNode &ndash; where the operand is a sink of the above configuration.</p>
</blockquote>
<blockquote>
<p>This gives us 64 potentially interesting conditionals to investigate. Note many of them are not direct calls to isReqAuthenticated, instead they test the result of some intermediate function which in turn calls isReqAuthenticated. The CodeQL global data flow analysis feature allows us to detect those.</p>
</blockquote>
<pre tabindex="0"><code class="language-ql" data-lang="ql">import go

class AuthTestConfig extends DataFlow::Configuration {

  AuthTestConfig() { this = &#34;auth-test-config&#34; }

  override predicate isSource(DataFlow::Node source) {
    source = any(DataFlow::CallNode cn |
      cn.getTarget().hasQualifiedName(&#34;github.com/minio/minio/cmd&#34;, &#34;isReqAuthenticated&#34;)
    ).getResult()
  }

  override predicate isSink(DataFlow::Node sink) {
    sink = any(DataFlow::EqualityTestNode n).getAnOperand()
  }

}

from AuthTestConfig config, DataFlow::Node sink, DataFlow::EqualityTestNode comparison
where config.hasFlow(_, sink) and comparison.getAnOperand() = sink
select comparison
</code></pre><p>哇塞, <del>是传说中的污点分析!</del> 其实严格意义上不算是, 这个算是数据流跟踪.</p>
<p><code>AuthTestConfig</code>定义了数据流配置, 其中<code>isSource</code>和<code>isSink</code>分别定义了污点分析中的数据流起点Source和数据流终点Sink. 这里Source为调用<code>isReqAuthenticated</code>函数的节点, Sink是比较测试节点中的操作数.</p>
<p>根据<a href="https://codeql.github.com/docs/ql-language-reference/expressions/#any">文档</a>, <code>any</code>这玩意的用法如下</p>
<pre tabindex="0"><code>any(&lt;variable declarations&gt; | &lt;formula&gt; | &lt;expression&gt;)
</code></pre><p><code>&lt;formula&gt;</code>是对variable的要求, 对于每一个满足要求的变量都会返回一个<code>&lt;expressions&gt;</code>, 如果没有<code>&lt;expressions&gt;</code>就返回variable本身, 因此可能会返回多个.</p>
<p>那么问题来了, source或者sink是怎么和any的多个返回值进行比较的呢? 其实答案在<a href="https://codeql.github.com/docs/ql-language-reference/formulas/#equality-1">文档</a>中已经描述了:</p>
<blockquote>
<p>For expressions A and B, the formula A = B holds if there is a pair of values—one from A and one from B—that are the same. In other words, A and B have at least one value in common. For example, [1 .. 2] = [2 .. 5] holds, since both expressions have the value 2.</p>
</blockquote>
<p>因此, 根据文档, <code>1 = [1..2]</code> 是成立的, 那么<code>isSource</code>和<code>isSink</code>中的比较也是成立的.</p>
<p>最后, <code>config.hasFlow(_, sink)</code> 中将source部分设置为<code>_</code>, 因为我们的查询中并不包含source, 而<code>comparison.getOperand() = sink</code>也是方便去查询出相应的比较测试节点.</p>
<h3 id="22-find-the-true-bug">2.2: Find the true bug!<a hidden class="anchor" aria-hidden="true" href="#22-find-the-true-bug">#</a></h3>
<blockquote>
<p>We can now put this dataflow query together with our query from step 1.6, and find all if statements that</p>
</blockquote>
<blockquote>
<ul>
<li>Are one of the equality tests returned in 2.1</li>
<li>Are testing equality against ErrNone</li>
<li>Do not contain a return statement in their then branch</li>
</ul>
</blockquote>
<pre tabindex="0"><code class="language-ql" data-lang="ql">import go

class AuthTestConfig extends DataFlow::Configuration {

  AuthTestConfig() { this = &#34;auth-test-config&#34; }

  override predicate isSource(DataFlow::Node source) {
    source = any(DataFlow::CallNode cn |
      cn.getTarget().hasQualifiedName(&#34;github.com/minio/minio/cmd&#34;, &#34;isReqAuthenticated&#34;)
    ).getResult()
  }

  override predicate isSink(DataFlow::Node sink) {
    sink = any(DataFlow::EqualityTestNode n).getAnOperand()
  }

}

EqualityTestExpr getAnAuthCheck() {
  exists(AuthTestConfig config, DataFlow::Node sink, DataFlow::EqualityTestNode comparison |
    config.hasFlow(_, sink) and comparison.getAnOperand() = sink |
    result = comparison.asExpr()
  )
}

from IfStmt i
where
i.getCond() = getAnAuthCheck() and
i.getCond().(EqualityTestExpr).getAnOperand().(Ident).getName() = &#34;ErrNone&#34;
and not i.getThen().getAStmt() instanceof ReturnStmt
select i
</code></pre><p>将之前的部分结合起来就可以了. 这里新出现了一个<code>exists</code>, 其用法为:</p>
<pre tabindex="0"><code>exists(&lt;variable declarations&gt; | &lt;formula&gt;)
</code></pre><p>当存在一个变量使得formula成立, 公式成立, 而formula可以有多个, 即</p>
<pre tabindex="0"><code>exists(&lt;variable declarations&gt; | &lt;formula 1&gt; | &lt;formula 2&gt; |...| &lt;formula n&gt;)
</code></pre><p>等价于</p>
<pre tabindex="0"><code>exists(&lt;variable declarations&gt; | &lt;formula 1&gt; and &lt;formula 2&gt; and...and &lt;formula n&gt;)
</code></pre><p>如果至少存在一组variables使得全部formula都满足, 那么公式成立.</p>
<p>而题解中的这种写法, 相当于等前面所有的formula都满足的时候, 临时变量result会被赋值 <code>comparison.asExpr()</code> , 而result又是 <code>getAnAuthCheck</code> 的返回值, 因此就变成: 返回一组满足运算单元是污点源的 <code>EqualityTestExpr</code>.</p>
<h2 id="part-3-expanding-the-query">Part 3: Expanding the query<a hidden class="anchor" aria-hidden="true" href="#part-3-expanding-the-query">#</a></h2>
<p>这部分要扩大范围, 不再局限于MinIO了, 使用的检测对象是这道题目附带的database.</p>
<h3 id="31-conditional-polarity">3.1: Conditional polarity<a hidden class="anchor" aria-hidden="true" href="#31-conditional-polarity">#</a></h3>
<blockquote>
<p>You might have noticed this in step 1.6: our code looking for equality tests encompases both x == ErrNone and x != ErrNone and checks the then block in both cases. This is wrong. It ought to check the &ldquo;then&rdquo; or &ldquo;else&rdquo; case of an if block, depending on which form of conditional is used. Modify your query to fix this problem. Your query should be able to detect all bad examples in conditionalPolarities.go.
Hint: Check out the predicate EqualityTestExpr.getPolarity</p>
</blockquote>
<p>需要根据<code>x==ErrNone</code>和<code>x!=ErrNone</code>的不同情况进行不同检查.</p>
<pre tabindex="0"><code class="language-ql" data-lang="ql">import go

class AuthTestConfig extends DataFlow::Configuration {

  AuthTestConfig() { this = &#34;auth-test-config&#34; }

  override predicate isSource(DataFlow::Node source) {
    source = any(DataFlow::CallNode cn |
      cn.getTarget().hasQualifiedName(&#34;github.com/minio/minio/cmd&#34;, &#34;isReqAuthenticated&#34;) or
      // Note new source function:
      cn.getTarget().hasQualifiedName(&#34;github.com/github/codeql-ctf-go-return&#34;, &#34;errorSource&#34;)
    ).getResult()
  }

  override predicate isSink(DataFlow::Node sink) {
    sink = any(DataFlow::EqualityTestNode n).getAnOperand()
  }

}

EqualityTestExpr getADirectAuthCheck(boolean polarity) {
  exists(AuthTestConfig config, DataFlow::Node sink, DataFlow::EqualityTestNode comparison |
    config.hasFlow(_, sink) and comparison.getAnOperand() = sink |
    result = comparison.asExpr() and
    polarity = result.getPolarity()
  )
}

/**
 * Given `ifStmt`&#39;s condition compares some `x` against `ErrNone` with `polarity` (true means checking
 * equality; false checking inequality), return the block reached when `x != ErrNone`.
 */
BlockStmt getErrorBranch(IfStmt ifStmt, boolean polarity) {
  polarity = [true, false] and
  if polarity = true then result = ifStmt.getElse() else result = ifStmt.getThen()
}

from IfStmt i, boolean testPolarity
where
i.getCond() = getADirectAuthCheck(testPolarity) and
i.getCond().(EqualityTestExpr).getAnOperand().(Ident).getName() = &#34;ErrNone&#34;
and not getErrorBranch(i, testPolarity).getAStmt() instanceof ReturnStmt
select i
</code></pre><p>重点是<code>if polarity = true then result = ifStmt.getElse() else result = ifStmt.getThen()</code>这一句.</p>
<p>另外<code>polarity = [true, false]</code>这个是对变量的限制, 在<a href="https://codeql.github.com/docs/ql-language-reference/predicates/#binding-behavior">文档</a>中有相关的描述</p>
<blockquote>
<p>It must be possible to evaluate a predicate in a finite amount of time, so the set it describes is not usually allowed to be infinite. In other words, a predicate can only contain a finite number of tuples.</p>
</blockquote>
<p>如果没有<code>polarity = [true, false]</code>, 虽然理论上来说boolean变量也只有两个值, 但是统一起见还是需要做限制.</p>
<h3 id="32-more-blocks">3.2: More blocks<a hidden class="anchor" aria-hidden="true" href="#32-more-blocks">#</a></h3>
<blockquote>
<p>Let&rsquo;s detect more blocks that must return. For example, our query fails to detect a return statement in an else branch, and there are other such cases that we need to handle, such as cascading else or switch/case. Modify your query to find more blocks that don’t return. Your query should be able to detect all bad examples in moreWaysToReturn.go.
Hints:
While we could recursively inspect the control-flow structures inside the if block, it may help to use the control-flow graph. Check the documentation of the class IR::ReturnInstruction, a control-flow graph node corresponding to a return statement, and the getAPredecessor() / getASuccessor() methods of its superclass ControlFlow::Node, which traverse control-flow graph edges.
A passing or failing if test is always followed by a ConditionGuardNode that indicates which branch was taken.</p>
</blockquote>
<blockquote>
<p>Tip: Try creating a temporary query such as the one below to get an idea what the control flow graph looks like.</p>
</blockquote>
<pre tabindex="0"><code class="language-ql" data-lang="ql">from ControlFlow::Node pred, ControlFlow::Node succ 
    where succ = pred.getASuccessor() // you can also restrict `pred` to come from a particular source file
    select pred, succ
</code></pre><p>要寻找更多分支语句中的没有返回的部分.</p>
<pre tabindex="0"><code class="language-ql" data-lang="ql">import go

class AuthTestConfig extends DataFlow::Configuration {

  AuthTestConfig() { this = &#34;auth-test-config&#34; }

  override predicate isSource(DataFlow::Node source) {
    source = any(DataFlow::CallNode cn |
      cn.getTarget().hasQualifiedName(&#34;github.com/minio/minio/cmd&#34;, &#34;isReqAuthenticated&#34;) or
      cn.getTarget().hasQualifiedName(&#34;github.com/github/codeql-ctf-go-return&#34;, &#34;errorSource&#34;)
    ).getResult()
  }

  override predicate isSink(DataFlow::Node sink) {
    sink = any(DataFlow::EqualityTestNode n).getAnOperand()
  }

}

EqualityTestExpr getAnAuthCheck() {
  exists(AuthTestConfig config, DataFlow::Node sink, DataFlow::EqualityTestNode comparison |
    config.hasFlow(_, sink) and comparison.getAnOperand() = sink |
    result = comparison.asExpr()
  )
}

ReturnStmt getAReturnStatementInBlock(BlockStmt b) {
  result = b.getAChild*()
}

predicate mustReachReturnInBlock(ControlFlow::Node node, BlockStmt b) {
  node.(IR::ReturnInstruction).getReturnStmt() = getAReturnStatementInBlock(b) or
  forex(ControlFlow::Node succ | succ = node.getASuccessor() | mustReachReturnInBlock(succ, b))
}

from IfStmt i, ControlFlow::ConditionGuardNode ifSucc
where
i.getCond() = getAnAuthCheck() and
i.getCond().(EqualityTestExpr).getAnOperand().(Ident).getName() = &#34;ErrNone&#34; and
ifSucc.ensures(DataFlow::exprNode(i.getCond()), true) and
not mustReachReturnInBlock(ifSucc, i.getThen())
select i
</code></pre><p><code>ifSucc.ensures(DataFlow::exprNode(i.getCond()), true)</code> 涉及到了控制流节点<code>ifSucc</code>, 这条语句的意思是 <strong>确保<code>i.getCond()</code>的条件成立</strong>, 成立之后才对then分支的语句进行分析.</p>
<p>关于ConditionGuardNode, <a href="https://codeql.github.com/docs/codeql-language-guides/codeql-library-for-go/#condition-guard-nodes">文档</a>中的有直观的实例.</p>
<p>对于以下代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">f</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span>
</span></span></code></pre></div><p>其ConditionGuardNode为图中的<code>p != nil is true</code>和<code>p != nil is false</code>.</p>
<hr>
<p>当变量调用谓词(predicate)的时候, 如果存在结果, 那么这种调用是一个表达式, 否则就是一个公式. 返回结果的谓词可以在经过逻辑判断后返回多个结果, 例如</p>
<pre tabindex="0"><code class="language-ql" data-lang="ql">string getANeighbor(string country) {
  country = &#34;France&#34; and result = &#34;Belgium&#34;
  or
  country = &#34;France&#34; and result = &#34;Germany&#34;
  or
  country = &#34;Germany&#34; and result = &#34;Austria&#34;
  or
  country = &#34;Germany&#34; and result = &#34;Belgium&#34;
}
</code></pre><p>对于上述predicate, 如果<code>country</code>为&quot;Germany&quot;, 那么返回值为Austria和Belgium, 这点和平时用的编程语言区别挺大的.</p>
<p>同样的, <code>b.getAChild()</code>是一个带结果的谓词调用, 会返回多个子节点.</p>
<p>接下来是代表闭包传递的<code>*</code>和<code>+</code>, 这两个都有迭代的功能, 例如<code>ReturnStmt getAChild*()</code> 等价于</p>
<pre tabindex="0"><code class="language-ql" data-lang="ql">ReturnStmt getOneChild() {
  result = this
  or
  result = this.getAChild().getOneChild()
}
</code></pre><p>而<code>ReturnStmt getAChild+()</code> 等价于</p>
<pre tabindex="0"><code class="language-ql" data-lang="ql">ReturnStmt getOneChild() {
  result = this.getAChild()
  or
  result = this.getAChild().getOneChild()
}
</code></pre><p>也就是说<code>*</code>相比较<code>+</code>还包含了自身.</p>
<p>那么<code>getAReturnStatementInBlock</code>的结果就是当前节点加上当前节点经过递归后的所有子节点.</p>
<p>那么子节点的集合要怎么和<code>node.(IR::ReturnInstruction).getReturnStmt()</code>进行比较? 根据<a href="https://codeql.github.com/docs/ql-language-reference/formulas/#equality-1">文档</a>中所描述的:</p>
<blockquote>
<p>For expressions A and B, the formula A = B holds if there is a pair of values—one from A and one from B—that are the same. In other words, A and B have at least one value in common. For example, [1 .. 2] = [2 .. 5] holds, since both expressions have the value 2.</p>
</blockquote>
<p>那么就不难理解了, 只要<code>node.(IR::ReturnInstruction).getReturnStmt()</code>的值和其中一个相同, <code>mustReachReturnInBlock</code>就会成立, 不然就进入<code>forex</code>部分.</p>
<p><code>forex</code>的用法, 根据<a href="https://codeql.github.com/docs/ql-language-reference/formulas/#forex">文档</a>, 可以看作是<code>forall</code> 和 <code>exists</code> 的结合. 三者的定义如下</p>
<pre tabindex="0"><code>forall(&lt;variable declarations&gt; | &lt;formula 1&gt; | &lt;formula 2&gt;)
forex(&lt;variable declarations&gt; | &lt;formula 1&gt; | &lt;formula 2&gt;) 等价于 forall(&lt;vars&gt; | &lt;formula 1&gt; | &lt;formula 2&gt;) and exists(&lt;vars&gt; | &lt;formula 1&gt; | &lt;formula 2&gt;)
</code></pre><ul>
<li><code>forall</code>: 当每一个让formula1 成立的变量在formula2成立的时候, 公式成立</li>
<li><code>forex</code>: 和<code>forall</code>类似, 但是排除了<code>不存在满足formula1的变量的情况</code>, 因为这种情况下<code>formula2</code>会无条件成立.</li>
</ul>
<p>那么代码中<code>forex</code>的意思就是: <strong>对于node的successor, 要求successor存在, 并且每一个successor满足mustReachReturnInBlock, 也就是说每一个successor都存在ReturnStmt</strong></p>
<hr>
<p>在查阅文档的时候可以注意类的<code>supertypes</code>都有哪些, 包括<code>Direct supertypes</code> 和 <code>Indirect supertypes</code>. 所谓<code>Indirect supertypes</code>就是指, <code>supertype</code>在经历了多次继承之后才能变成该类, 而<code>direct supertypes</code> 是直接继承的. 这些<code>supertypes</code>都可以通过类型转换变成这个类.</p>
<h3 id="33-wrapped-conditionals">3.3: Wrapped conditionals<a hidden class="anchor" aria-hidden="true" href="#33-wrapped-conditionals">#</a></h3>
<blockquote>
<p>Now we can have cases where our equality test against ErrNone is no longer directly used in a conditional statement, but is instead wrapped inside a utility function. Modify your query to handle this case. Your query should be able to detect all bad examples in wrapperFunctions.go.</p>
</blockquote>
<p>Hint:</p>
<ul>
<li>You can have several layers in your wrap!</li>
<li>Check out the predicates CallExpr::getTarget(), DataFlow::CallNode::getTarget() and Function::getFuncDecl() to navigate between a callsite and its callee.</li>
</ul>
<p>相比较之前的直接查询if语句中的内容, 这里要求额外覆盖使用函数返回值进行判断的情况, 例如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">succeeded</span>(<span style="color:#a6e22e">errorSource</span>()) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">doSomething</span>()
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Bad: despite an error, we carry on to execute doSomething()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">insteadOfReturn</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code class="language-ql" data-lang="ql">import go

class AuthTestConfig extends DataFlow::Configuration {

  AuthTestConfig() { this = &#34;auth-test-config&#34; }

  override predicate isSource(DataFlow::Node source) {
    source = any(DataFlow::CallNode cn |
      cn.getTarget().hasQualifiedName(&#34;github.com/minio/minio/cmd&#34;, &#34;isReqAuthenticated&#34;) or
      // Note new source function:
      cn.getTarget().hasQualifiedName(&#34;github.com/github/codeql-ctf-go-return&#34;, &#34;errorSource&#34;)
    ).getResult()
  }

  override predicate isSink(DataFlow::Node sink) {
    sink = any(DataFlow::EqualityTestNode n).getAnOperand()
  }

}

EqualityTestExpr getADirectAuthCheck(boolean polarity) {
  exists(AuthTestConfig config, DataFlow::Node sink, DataFlow::EqualityTestNode comparison |
    config.hasFlow(_, sink) and comparison.getAnOperand() = sink |
    result = comparison.asExpr() and
    result.getAnOperand().(Ident).getName() = &#34;ErrNone&#34; and
    polarity = result.getPolarity()
  )
}

CallExpr getACheckCall(boolean polarity, FuncDecl target, Expr innerCheck) {
  innerCheck = getAnAuthCheck(polarity) and
  target = result.getTarget().getFuncDecl() and
  forex(DataFlow::ResultNode rn | rn.getRoot() = target | rn.asExpr() = innerCheck)
}

Expr getAnAuthCheck(boolean polarity) {
  result = getADirectAuthCheck(polarity) or
  result = getACheckCall(polarity, _, _)
}

/**
 * Given `ifStmt`&#39;s condition compares some `x` against `ErrNone` with `polarity` (true means checking
 * equality; false checking inequality), return the block reached when `x != ErrNone`.
 */
BlockStmt getErrorBranch(IfStmt ifStmt, boolean polarity) {
  polarity = [true, false] and
  if polarity = true then result = ifStmt.getElse() else result = ifStmt.getThen()
}

from IfStmt i, boolean testPolarity
where
i.getCond() = getAnAuthCheck(testPolarity)
and not getErrorBranch(i, testPolarity).getAStmt() instanceof ReturnStmt
select i
</code></pre><p><code>getErrorBranch</code> 没什么好说的, 就是根据<code>polarity</code>选择else分支或者then分支.</p>
<p>但是<code>getAnAuthCheck</code>就不同了, 这里用到了一个相当高级的写法: 相互递归(Mutal Recursion), 这会形成谓词之间的依赖链条, 可以看<a href="https://codeql.github.com/docs/ql-language-reference/recursion/#mutual-recursion">文档</a> 给出的一个例子.</p>
<pre tabindex="0"><code class="language-ql" data-lang="ql">int getAnEven() {
  result = 0
  or
  result &lt;= 100 and result = getAnOdd() + 1
}

int getAnOdd() {
  result = getAnEven() + 1
}

select getAnEven()
</code></pre><p>在这个例子中<code>getAnEven</code>和<code>getAnOdd</code>之间形成了谓词依赖链条, codeql会持续递归到限制条件后返回0到100的偶数.</p>
<p><code>getAnAuthCheck</code>和<code>getACheckCall</code>之间也存在相互递归的关系. <code>getAnAuthCheck</code> 首先根据<code>polarity</code>的值去选择<code>xxx==ErrNone</code>或<code>xxx!=ErrorNone</code>这两种sink并转化为表达式, 和之前的差不多, 而<code>getACheckCall</code>中, 首先会反过来递归获取<code>getAnAuthCheck</code>的结果.</p>
<p>定义<code>target</code>为函数的声明, 同时也对<code>CallExpr</code>类型的<code>result</code>作了隐式的定义.</p>
<p>接下来, <code>forex</code>对每一个<code>DataFlow::ResultNode</code> 进行检查, <code>DataFlow::ResultNode</code> 在<a href="https://codeql.github.com/codeql-standard-libraries/go/semmle/go/dataflow/internal/DataFlowNodes.qll/type.DataFlowNodes$Public$ResultNode.html">文档</a>中描述为:</p>
<blockquote>
<p>This can either be a node corresponding to an expression in a return statement, or a node representing the current value of a named result variable at the exit of the function.</p>
</blockquote>
<p>而<code>getRoot</code>能够获取节点所属的函数, 这个<code>forex</code>的意思就成为了 <strong>要求每一个ResultNode所属的函数都与target代表的函数对应, 同时ResultNode的表达式是getAnAuthCheck的结果, 也就是innerCheck</strong></p>
<p>那么<code>innerCheck</code>也就是<code>getAnAuthCheck(polarity)</code>, 代表的就是<strong>条件判断的sink, 以及条件判断中所使用的存在条件判断sink的函数</strong>.</p>
<h3 id="34-more-conditionals">3.4: More conditionals<a hidden class="anchor" aria-hidden="true" href="#34-more-conditionals">#</a></h3>
<blockquote>
<p>Our code works for simple equality tests, but there are cases where this test is part of a bigger test with conditionals involving !, &amp;&amp;, ||, that are not currently accounted for in our query. Improve your query to handle these cases. Your query should be able to detect all bad examples in logicalOperators.go.
Hint: Check out ControlFlow::ConditionGuardNode. This node flags a point in a control-flow graph where a particular test is known to have passed or failed, including those nested within the short-circuiting binary logical operators &amp;&amp;, ||. Its predicate ensures can already analyse some boolean expression structure. Even if you cannot use it directly, the implementation of ensures may be a useful inspiration for your solution. See the hints for Step 3.2 for more information about the control-flow graph.</p>
</blockquote>
<p>也就是说要对!x, x||y, x &amp;&amp; y, (x) 这些情况进行处理.</p>
<pre tabindex="0"><code class="language-ql" data-lang="ql">import go

class AuthTestConfig extends DataFlow::Configuration {

  AuthTestConfig() { this = &#34;auth-test-config&#34; }

  override predicate isSource(DataFlow::Node source) {
    source = any(DataFlow::CallNode cn |
      cn.getTarget().hasQualifiedName(&#34;github.com/minio/minio/cmd&#34;, &#34;isReqAuthenticated&#34;) or
      // Note new source function:
      cn.getTarget().hasQualifiedName(&#34;github.com/github/codeql-ctf-go-return&#34;, &#34;errorSource&#34;)
    ).getResult()
  }

  override predicate isSink(DataFlow::Node sink) {
    sink = any(DataFlow::EqualityTestNode n).getAnOperand()
  }

}

EqualityTestExpr getADirectAuthCheck(boolean polarity) {
  exists(AuthTestConfig config, DataFlow::Node sink, DataFlow::EqualityTestNode comparison |
    config.hasFlow(_, sink) and comparison.getAnOperand() = sink |
    result = comparison.asExpr() and
    polarity = result.getPolarity()
  )
}

Expr getAnAuthCheck(Boolean noError, EqualityTestExpr test) {
  result = getADirectAuthCheck(noError) and test = result
  or
  result.(ParenExpr).getExpr() = getAnAuthCheck(noError, test)
  or
  result.(NotExpr).getOperand() = getAnAuthCheck(noError.booleanNot(), test)
  or
  result.(LandExpr).getRightOperand() = getAnAuthCheck(noError, test)
  or
  result.(LandExpr).getLeftOperand() = getAnAuthCheck(true, test) and noError = true
  or
  result.(LandExpr).getLeftOperand() = getAnAuthCheck(false, test) and noError = [true, false]
  or
  result.(LorExpr).getRightOperand() = getAnAuthCheck(noError, test)
  or
  result.(LorExpr).getLeftOperand() = getAnAuthCheck(false, test) and noError = false
  or
  result.(LorExpr).getLeftOperand() = getAnAuthCheck(true, test) and noError = [true, false]
}


BlockStmt getErrorBranch(IfStmt ifStmt, boolean polarity) {
  polarity = [true, false] and
  if polarity = true then result = ifStmt.getElse() else result = ifStmt.getThen()
}

from IfStmt i, EqualityTestExpr test
where
test.getAnOperand().(Ident).getName() = &#34;ErrNone&#34;
and not forall(boolean testPolarity |
  i.getCond() = getAnAuthCheck(testPolarity, test) |
  exists(Stmt s | s = getErrorBranch(i, testPolarity).getAStmt() | s instanceof ReturnStmt))
and i.getFile().getBaseName() = &#34;logicalOperators.go&#34;
select i
</code></pre><p><code>getAnAuthCheck</code>是重点</p>
<pre tabindex="0"><code class="language-ql" data-lang="ql">// 使用test来约束直接检查的结果: 必须是有ErrNone参与的等式检查
  result = getADirectAuthCheck(noError) and result = test
or
  // 对getAnAuthCheck的结果进行约束, 结果必须为一个ParenExpr中去掉括号的Expr
    // 如果存在这样的结果, 那么这里的result就满足要求了
  result.(ParenExpr).getExpr() = getAnAuthCheck(noError, test)
or
  // 对getAnAuthCheck的结果进行约束, 结果必须为一个NotExpr中去掉Not部分的Expr
  result.(NotExpr).getOperand() = getAnAuthCheck(noError.booleanNot(), test)
</code></pre><p>但是接下来的那几个AND和OR相关的处理我就看不懂了, 后续再说吧.</p>
<p>最后应该说明一下<code>forall</code>和<code>exists</code>的组合使用:</p>
<pre tabindex="0"><code class="language-ql" data-lang="ql">// 所有满足污点和ErrNone参与的条件检查中, 每一个分支里都存在返回语句
forall(boolean testPolarity |
  i.getCond() = getAnAuthCheck(testPolarity, test) |
// 如果错误分支中存在返回语句, 那么成立
  exists(Stmt s | s = getErrorBranch(i, testPolarity).getAStmt() | s instanceof ReturnStmt))
</code></pre><p>将上面的逻辑取反, 就变成了 <strong>所有满足污点和ErrNone参与的条件检查中, 存在不包含返回语句的分支</strong>.</p>
<h3 id="35-valid-returns-only">3.5: Valid returns only<a hidden class="anchor" aria-hidden="true" href="#35-valid-returns-only">#</a></h3>
<blockquote>
<p>Ok, so now we make sure we return something when we check the permission. But is that enough? Just returning somehow isn&rsquo;t good enough, we may also need to return an appropriate value. The use of non-nil / nil error values is normal to indicate an error in Go, so let’s assume for this problem that non-nil is considered an appropriate return value. Modify your query to detect all bad examples in checkReturnValue.go.</p>
</blockquote>
<p>需要检测那些和ErrNone比较后可能返回nil的情况.</p>
<pre tabindex="0"><code class="language-ql" data-lang="ql">
import go

class AuthTestConfig extends DataFlow::Configuration {

  AuthTestConfig() { this = &#34;auth-test-config&#34; }

  override predicate isSource(DataFlow::Node source) {
    source = any(DataFlow::CallNode cn |
      cn.getTarget().hasQualifiedName(&#34;github.com/minio/minio/cmd&#34;, &#34;isReqAuthenticated&#34;) or
      // Note new source function:
      cn.getTarget().hasQualifiedName(&#34;github.com/github/codeql-ctf-go-return&#34;, &#34;errorSource&#34;)
    ).getResult()
  }

  override predicate isSink(DataFlow::Node sink) {
    sink = any(DataFlow::EqualityTestNode n).getAnOperand()
  }

}

predicate returnsNil(FuncDecl f) {
  forex(DataFlow::ResultNode r | r.getRoot() = f | r = Builtin::nil().getARead())
}

predicate isNil(Expr e) {
  e = any(CallExpr c | returnsNil(c.getTarget().getFuncDecl())) or
  e = Builtin::nil().getAReference()
}

EqualityTestExpr getADirectAuthCheck(boolean polarity) {
  exists(AuthTestConfig config, DataFlow::Node sink, DataFlow::EqualityTestNode comparison |
    config.hasFlow(_, sink) and comparison.getAnOperand() = sink |
    result = comparison.asExpr() and
    polarity = result.getPolarity()
  )
}

/**
 * Given `ifStmt`&#39;s condition compares some `x` against `ErrNone` with `polarity` (true means checking
 * equality; false checking inequality), return the block reached when `x != ErrNone`.
 */
BlockStmt getErrorBranch(IfStmt ifStmt, boolean polarity) {
  polarity = [true, false] and
  if polarity = true then result = ifStmt.getElse() else result = ifStmt.getThen()
}

from IfStmt i, boolean testPolarity, int resultIdx
where
i.getCond() = getADirectAuthCheck(testPolarity) and
i.getCond().(EqualityTestExpr).getAnOperand().(Ident).getName() = &#34;ErrNone&#34; and
i.getEnclosingFunction().getType().getResultType(resultIdx) = Builtin::error().getType() and // i 所属函数的返回值类型中有错误类型
not exists(ReturnStmt r |
  r = getErrorBranch(i, testPolarity).getAStmt() |
  not isNil(r.getExpr(resultIdx))
) // 这个错误类型不是nil
select i
</code></pre>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://dragonbox.top/posts/tech-domain/">
    <span class="title">« Prev</span>
    <br>
    <span>域名配合隧道穿透服务(Godaddy&#43;Cloudflare&#43;Cpolar)</span>
  </a>
  <a class="next" href="https://dragonbox.top/posts/gossip-scihub/">
    <span class="title">Next »</span>
    <br>
    <span>从$scihub到自由网络意志</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://dragonbox.top/">ch3n9w の 超元域</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
